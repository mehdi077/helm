### Configuring OpenRouterClient Options in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/quick-start.md

Illustrates common variations for OpenRouterClient initialization, including setting request timeouts, enabling retries, and retrieving the API key from an environment variable for secure and robust client setup.

```C#
// With timeout configuration
var client = new OpenRouterClient("your-api-key", options =>
{
    options.RequestTimeout = TimeSpan.FromSeconds(60);
    options.EnableRetry = true;
    options.MaxRetryAttempts = 3;
});

// Using environment variable
var apiKey = Environment.GetEnvironmentVariable("OPENROUTER_API_KEY")
    ?? throw new InvalidOperationException("API key not found");
var client = new OpenRouterClient(apiKey);
```

--------------------------------

### Initializing OpenRouterClient in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/quick-start.md

Demonstrates the simplest way to create an OpenRouterClient instance using an API key and make a basic chat completion request. It shows the fluent API for chaining method calls and asynchronous execution.

```C#
using OpenRouter.Core;

// Create client with API key
var client = new OpenRouterClient("your-api-key-here");

// Make a simple chat completion request
var response = await client.Chat
    .CreateChatCompletion("gpt-3.5-turbo")
    .AddUserMessage("Hello, world!")
    .SendAsync();

Console.WriteLine(response.FirstChoiceContent);
```

--------------------------------

### Development Environment OpenRouter Configuration (JSON)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/quick-start.md

This JSON snippet defines development-specific settings for OpenRouter, enabling logging, setting the log level to 'Debug', and configuring a 5-minute request timeout.

```json
// appsettings.Development.json
{
  "OpenRouter": {
    "EnableLogging": true,
    "LogLevel": "Debug",
    "RequestTimeout": "00:05:00"
  }
}
```

--------------------------------

### Processing Multiple Chat Choices in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/quick-start.md

Shows how to iterate through multiple choices in a ChatCompletionResponse and access details like message content and finish reason. It also demonstrates checking the completion status of the first choice.

```C#
// Process multiple choices if available
foreach (var choice in response.Choices)
{
    Console.WriteLine($"Choice {choice.Index}: {choice.Message?.Content}");
    Console.WriteLine($"Finish Reason: {choice.FinishReason}");
}

// Check completion status
var firstChoice = response.Choices.FirstOrDefault();
if (firstChoice?.IsCompleted == true)
{
    Console.WriteLine("Response completed successfully");
}
```

--------------------------------

### Handling Chat Completion Responses in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/quick-start.md

Provides a comprehensive example of making a chat completion request, accessing response details like ID, model, and content, and handling potential API errors using OpenRouterException. It also shows how to check token usage.

```C#
using OpenRouter.Core;
using OpenRouter.Models.Responses;

var client = new OpenRouterClient("your-api-key");

try
{
    var response = await client.Chat
        .CreateChatCompletion("anthropic/claude-3-haiku")
        .AddSystemMessage("You are a helpful programming assistant.")
        .AddUserMessage("Explain what async/await means in C#")
        .WithTemperature(0.7)
        .WithMaxTokens(200)
        .SendAsync();

    // Access response details
    Console.WriteLine($"Response ID: {response.Id}");
    Console.WriteLine($"Model Used: {response.Model}");
    Console.WriteLine($"Created: {response.CreatedAt:yyyy-MM-dd HH:mm:ss}");
    
    // Get the response content
    var content = response.FirstChoiceContent;
    Console.WriteLine($"Response: {content}");
    
    // Check token usage
    if (response.Usage != null)
    {
        Console.WriteLine($"Tokens used: {response.Usage.TotalTokens}");
        Console.WriteLine($"  - Prompt: {response.Usage.PromptTokens}");
        Console.WriteLine($"  - Completion: {response.Usage.CompletionTokens}");
    }
}
catch (OpenRouterException ex)
{
    Console.WriteLine($"API Error: {ex.Message}");
    Console.WriteLine($"Error Type: {ex.ErrorType}");
    Console.WriteLine($"Status Code: {ex.StatusCode}");
}
```

--------------------------------

### Configuring OpenRouter Services in ASP.NET Core

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/quick-start.md

This snippet demonstrates how to register OpenRouter services in an ASP.NET Core application's `Program.cs` file. It configures the API key, base URL, retry logic, and request timeout for the OpenRouter client, ensuring proper setup for API interactions.

```C#
// Program.cs
using OpenRouter.Extensions;

var builder = WebApplication.CreateBuilder(args);

// Add OpenRouter services
builder.Services.AddOpenRouter(options =>
{
    options.ApiKey = builder.Configuration["OpenRouter:ApiKey"]!;
    options.BaseUrl = "https://openrouter.ai/api/v1";
    options.EnableRetry = true;
    options.MaxRetryAttempts = 3;
    options.RetryDelay = TimeSpan.FromSeconds(1);
    options.RequestTimeout = TimeSpan.FromSeconds(120);
});

// Add other services
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

app.Run();
```

--------------------------------

### Using OpenRouter Client in a C# Service

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/quick-start.md

This C# class illustrates how to inject and use `OpenRouterOptions` and `IOpenRouterClient` within a service. It demonstrates creating a chat completion with configurable model, temperature, and max tokens based on the injected options.

```csharp
public class ConfigurableService
{
    private readonly OpenRouterOptions _options;
    private readonly IOpenRouterClient _client;

    public ConfigurableService(IOptions<OpenRouterOptions> options, IOpenRouterClient client)
    {
        _options = options.Value;
        _client = client;
    }

    public async Task<string> GetResponseAsync(string prompt)
    {
        var response = await _client.Chat
            .CreateChatCompletion(_options.DefaultModel ?? "gpt-3.5-turbo")
            .AddUserMessage(prompt)
            .WithTemperature(_options.DefaultTemperature ?? 0.7)
            .WithMaxTokens(_options.DefaultMaxTokens ?? 150)
            .SendAsync();

        return response.FirstChoiceContent;
    }
}
```

--------------------------------

### Configuring OpenRouter Client from appsettings.json (C# & JSON)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/getting-started.md

This example illustrates how to configure the OpenRouter client using values defined in `appsettings.json`. The C# snippet shows how to bind a configuration section to the OpenRouter options, while the JSON snippet provides the structure for the `OpenRouter` section in `appsettings.json`, including `ApiKey`, `BaseUrl`, `Timeout`, `EnableRetry`, and `MaxRetryAttempts`.

```csharp
// Program.cs
builder.Services.AddOpenRouter(options =>
    builder.Configuration.GetSection("OpenRouter").Bind(options));
```

```json
// appsettings.json
{
  "OpenRouter": {
    "ApiKey": "your_api_key_here",
    "BaseUrl": "https://openrouter.ai/api/v1",
    "Timeout": "00:00:30",
    "EnableRetry": true,
    "MaxRetryAttempts": 3
  }
}
```

--------------------------------

### Performing a Simple Chat Completion Request (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/getting-started.md

This C# example demonstrates how to use the OpenRouterClient to create and send a basic chat completion request to the 'gpt-3.5-turbo' model, adding a user message and handling potential API errors.

```csharp
using OpenRouter.Core;

var client = new OpenRouterClient("YOUR_API_KEY");

try
{
    var response = await client.Chat
        .CreateChatCompletion("gpt-3.5-turbo")
        .AddUserMessage("What is the capital of France?")
        .SendAsync();

    Console.WriteLine($"Response: {response.FirstChoiceContent}");
    Console.WriteLine($"Model: {response.Model}");
    Console.WriteLine($"Usage: {response.Usage?.TotalTokens} tokens");
}
catch (OpenRouterException ex)
{
    Console.WriteLine($"API Error: {ex.Message}");
}
```

--------------------------------

### Cloning the OpenRouter .NET Repository (Bash)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/getting-started.md

This snippet provides the command to clone the OpenRouter .NET library's GitHub repository, which is the first step for local development or adding a project reference manually.

```bash
git clone https://github.com/xyOz-dev/OpenRouter.git
```

--------------------------------

### Binding OpenRouter Configuration in C# (Program.cs)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/quick-start.md

This C# code demonstrates advanced configuration binding for OpenRouter options. It shows how to bind a configuration section, register the client with validation, override settings with environment variables, and add data annotation validation for options.

```csharp
// Program.cs - Advanced configuration
var builder = WebApplication.CreateBuilder(args);

// Bind configuration to options
builder.Services.Configure<OpenRouterOptions>(
    builder.Configuration.GetSection("OpenRouter"));

// Register with configuration validation
builder.Services.AddOpenRouter(options =>
{
    builder.Configuration.GetSection("OpenRouter").Bind(options);
    
    // Override with environment variables if present
    options.ApiKey = Environment.GetEnvironmentVariable("OPENROUTER_API_KEY") ?? options.ApiKey;
    
    // Validate required settings
    if (string.IsNullOrEmpty(options.ApiKey))
    {
        throw new InvalidOperationException("OpenRouter API key is required");
    }
});

// Add options validation
builder.Services.AddOptions<OpenRouterOptions>()
    .Configure<IConfiguration>((options, config) =>
    {
        config.GetSection("OpenRouter").Bind(options);
    })
    .ValidateDataAnnotations()
    .ValidateOnStart();
```

--------------------------------

### Initializing OpenRouterClient Instances (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/getting-started.md

This C# snippet shows two ways to initialize an OpenRouterClient: a basic instance with just an API key, and a more advanced instance with custom configuration options like BaseUrl, Timeout, EnableRetry, and MaxRetryAttempts.

```csharp
using OpenRouter.Core;

// Basic client with API key
var client = new OpenRouterClient("YOUR_API_KEY");

// Client with custom configuration
var client = new OpenRouterClient("YOUR_API_KEY", options =>
{
    options.BaseUrl = "https://openrouter.ai/api/v1";
    options.Timeout = TimeSpan.FromSeconds(30);
    options.EnableRetry = true;
    options.MaxRetryAttempts = 3;
});
```

--------------------------------

### Production Environment OpenRouter Configuration (JSON)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/quick-start.md

This JSON snippet defines production-specific settings for OpenRouter, disabling logging, setting the log level to 'Warning', configuring a 1-minute 30-second request timeout, and allowing 5 retry attempts.

```json
// appsettings.Production.json
{
  "OpenRouter": {
    "EnableLogging": false,
    "LogLevel": "Warning",
    "RequestTimeout": "00:01:30",
    "MaxRetryAttempts": 5
  }
}
```

--------------------------------

### Configuring OpenRouter Client Settings in appsettings.json

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/quick-start.md

This JSON snippet illustrates the typical `appsettings.json` configuration for the OpenRouter client. It defines API key, base URL, timeouts, retry logic, logging levels, and default model parameters, allowing for environment-specific adjustments.

```json
{
  "OpenRouter": {
    "ApiKey": "your-api-key-here",
    "BaseUrl": "https://openrouter.ai/api/v1",
    "RequestTimeout": "00:02:00",
    "EnableRetry": true,
    "MaxRetryAttempts": 3,
    "RetryDelay": "00:00:01",
    "EnableLogging": true,
    "LogLevel": "Information",
    "ValidateApiKey": true,
    "ThrowOnApiErrors": true,
    "DefaultModel": "gpt-3.5-turbo",
    "DefaultTemperature": 0.7,
    "DefaultMaxTokens": 150
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "OpenRouter": "Debug",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
```

--------------------------------

### Advanced OpenRouterClient Initialization with OpenRouterOptions (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/getting-started.md

This C# snippet illustrates how to create and configure an OpenRouterOptions object with various settings like API key, base URL, timeouts, retry logic, logging, and validation, then use it to initialize an OpenRouterClient with a custom OpenRouterHttpClient.

```csharp
var options = new OpenRouterOptions
{
    ApiKey = "YOUR_API_KEY",
    BaseUrl = "https://openrouter.ai/api/v1",
    Timeout = TimeSpan.FromSeconds(30),
    RequestTimeout = TimeSpan.FromSeconds(120),
    MaxRetryAttempts = 3,
    RetryDelay = TimeSpan.FromSeconds(1),
    EnableRetry = true,
    EnableLogging = true,
    LogLevel = LogLevel.Information,
    ValidateApiKey = true,
    ThrowOnApiErrors = true
};

var client = new OpenRouterClient(
    new OpenRouterHttpClient(new HttpClient(), 
        new BearerTokenProvider(options.ApiKey, options.ValidateApiKey), 
        options, null), 
    options);
```

--------------------------------

### Retrieving OpenRouter API Key from Environment Variable (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/getting-started.md

This C# snippet demonstrates how to retrieve the OPENROUTER_API_KEY from environment variables and use it to initialize an OpenRouterClient, ensuring the API key is not hardcoded in the application.

```csharp
var apiKey = Environment.GetEnvironmentVariable("OPENROUTER_API_KEY")
    ?? throw new InvalidOperationException("OPENROUTER_API_KEY not found");

var client = new OpenRouterClient(apiKey);
```

--------------------------------

### Setting OpenRouter API Key as Environment Variable (Bash/PowerShell)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/getting-started.md

These commands illustrate how to set the OPENROUTER_API_KEY environment variable across different operating systems (Windows Command Prompt, PowerShell, macOS/Linux) for secure API key management.

```bash
# Windows (Command Prompt)
set OPENROUTER_API_KEY=your_api_key_here

# Windows (PowerShell)
$env:OPENROUTER_API_KEY="your_api_key_here"

# macOS/Linux
export OPENROUTER_API_KEY="your_api_key_here"
```

--------------------------------

### Adding OpenRouter Project Reference to .csproj (XML)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/getting-started.md

This XML snippet demonstrates how to manually add a project reference to the OpenRouter library within a .NET project's .csproj file, linking it for compilation and dependency resolution.

```xml
<ProjectReference Include="path/to/OpenRouter/OpenRouter.csproj" />
```

--------------------------------

### Implementing Robust Error Handling with OpenRouter Client in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/quick-start.md

This C# snippet demonstrates a comprehensive try-catch pattern for interacting with the OpenRouter API. It handles various `OpenRouterException` types, including authentication, rate limiting with exponential backoff, model-specific errors, and network issues, ensuring resilient communication and proper logging.

```csharp
using OpenRouter.Core;
using OpenRouter.Core.Exceptions;

public class ChatService
{
    private readonly IOpenRouterClient _client;
    private readonly ILogger<ChatService> _logger;

    public ChatService(IOpenRouterClient client, ILogger<ChatService> logger)
    {
        _client = client;
        _logger = logger;
    }

    public async Task<string> GetCompletionAsync(string prompt, string model = "gpt-3.5-turbo")
    {
        const int maxRetries = 3;
        var retryCount = 0;

        while (retryCount < maxRetries)
        {
            try
            {
                _logger.LogInformation("Attempting chat completion (attempt {Attempt})", retryCount + 1);

                var response = await _client.Chat
                    .CreateChatCompletion(model)
                    .AddUserMessage(prompt)
                    .WithTimeout(TimeSpan.FromSeconds(30))
                    .SendAsync();

                _logger.LogInformation("Chat completion successful");
                return response.FirstChoiceContent;
            }
            catch (OpenRouterAuthenticationException ex)
            {
                _logger.LogError(ex, "Authentication failed - check API key");
                throw new InvalidOperationException("Invalid API credentials", ex);
            }
            catch (OpenRouterRateLimitException ex)
            {
                _logger.LogWarning("Rate limit exceeded, waiting {Delay}ms", ex.RetryAfterMs);
                
                if (ex.RetryAfterMs > 0)
                {
                    await Task.Delay(TimeSpan.FromMilliseconds(ex.RetryAfterMs));
                }
                
                retryCount++;
                continue;
            }
            catch (OpenRouterModelException ex)
            {
                _logger.LogError(ex, "Model error: {Message}", ex.Message);
                throw new ArgumentException($"Model '{model}' error: {ex.Message}", ex);
            }
            catch (OpenRouterNetworkException ex)
            {
                _logger.LogWarning(ex, "Network error on attempt {Attempt}", retryCount + 1);
                
                retryCount++;
                if (retryCount >= maxRetries)
                {
                    _logger.LogError("Max retries exceeded for network errors");
                    throw new ServiceUnavailableException("OpenRouter service is unavailable", ex);
                }
                
                await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, retryCount))); // Exponential backoff
                continue;
            }
            catch (OpenRouterException ex)
            {
                _logger.LogError(ex, "OpenRouter API error: {ErrorType}", ex.ErrorType);
                throw new ApplicationException($"API error: {ex.Message}", ex);
            }
            catch (TaskCanceledException ex) when (ex.InnerException is TimeoutException)
            {
                _logger.LogWarning("Request timeout on attempt {Attempt}", retryCount + 1);
                
                retryCount++;
                if (retryCount >= maxRetries)
                {
                    throw new TimeoutException("Request timed out after multiple attempts", ex);
                }
                continue;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error during chat completion");
                throw new ApplicationException("An unexpected error occurred", ex);
            }
        }

        throw new ApplicationException("Failed to complete request after all retries");
    }
}

public class ServiceUnavailableException : Exception
{
    public ServiceUnavailableException(string message, Exception innerException) 
        : base(message, innerException) { }
}
```

--------------------------------

### Injecting IOpenRouterClient into ASP.NET Core Controller (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/getting-started.md

This snippet demonstrates how to inject the `IOpenRouterClient` into an ASP.NET Core controller via constructor injection. It shows a `ChatController` that uses the client to create a chat completion, handles user prompts, and manages potential `OpenRouterException` errors, returning appropriate HTTP responses.

```csharp
[ApiController]
[Route("api/[controller]")]
public class ChatController : ControllerBase
{
    private readonly IOpenRouterClient _openRouterClient;

    public ChatController(IOpenRouterClient openRouterClient)
    {
        _openRouterClient = openRouterClient;
    }

    [HttpPost("complete")]
    public async Task<IActionResult> Complete([FromBody] string prompt)
    {
        try
        {
            var response = await _openRouterClient.Chat
                .CreateChatCompletion("gpt-3.5-turbo")
                .AddUserMessage(prompt)
                .SendAsync();

            return Ok(new { content = response.FirstChoiceContent });
        }
        catch (OpenRouterException ex)
        {
            return BadRequest(new { error = ex.Message });
        }
    }
}
```

--------------------------------

### Implementing OpenRouter Chat Completion Controller in ASP.NET Core

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/quick-start.md

This snippet shows an ASP.NET Core API controller (`ChatController`) that uses the `IOpenRouterClient` to perform chat completions. It defines an HTTP POST endpoint to accept chat requests, interact with the OpenRouter API, and return responses, including robust error handling and logging.

```C#
// Controllers/ChatController.cs
using Microsoft.AspNetCore.Mvc;
using OpenRouter.Core;

[ApiController]
[Route("api/[controller]")]
public class ChatController : ControllerBase
{
    private readonly IOpenRouterClient _openRouterClient;
    private readonly ILogger<ChatController> _logger;

    public ChatController(IOpenRouterClient openRouterClient, ILogger<ChatController> logger)
    {
        _openRouterClient = openRouterClient;
        _logger = logger;
    }

    [HttpPost("complete")]
    public async Task<IActionResult> Complete([FromBody] ChatRequest request)
    {
        try
        {
            _logger.LogInformation("Processing chat completion request");

            var response = await _openRouterClient.Chat
                .CreateChatCompletion(request.Model ?? "gpt-3.5-turbo")
                .AddUserMessage(request.Message)
                .WithTemperature(request.Temperature ?? 0.7)
                .WithMaxTokens(request.MaxTokens ?? 150)
                .SendAsync();

            return Ok(new ChatApiResponse 
            {
                Content = response.FirstChoiceContent,
                Model = response.Model,
                TokensUsed = response.Usage?.TotalTokens ?? 0
            });
        }
        catch (OpenRouterException ex)
        {
            _logger.LogError(ex, "OpenRouter API error");
            return BadRequest(new { error = ex.Message, type = ex.ErrorType });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error");
            return StatusCode(500, new { error = "Internal server error" });
        }
    }
}

public class ChatRequest
{
    public required string Message { get; set; }
    public string? Model { get; set; }
    public double? Temperature { get; set; }
    public int? MaxTokens { get; set; }
}

public class ChatApiResponse
{
    public required string Content { get; set; }
    public required string Model { get; set; }
    public int TokensUsed { get; set; }
}
```

--------------------------------

### Installing OpenRouter Library via Git Clone - Bash

Source: https://github.com/xyoz-dev/openrouter/blob/master/README.md

This snippet demonstrates how to install the OpenRouter .NET library by cloning its GitHub repository. This method is suitable for local development or contributing to the library.

```Bash
git clone https://github.com/xyOz-dev/OpenRouter.git
```

--------------------------------

### Registering OpenRouter Client with Dependency Injection (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/getting-started.md

This snippet demonstrates how to register the OpenRouter client with the ASP.NET Core DI container. It shows two methods: basic registration using an API key directly, and a more configurable approach allowing options like `BaseUrl`, `EnableRetry`, and `MaxRetryAttempts` to be set programmatically.

```csharp
using OpenRouter.Extensions;

var builder = WebApplication.CreateBuilder(args);

// Basic registration with API key
builder.Services.AddOpenRouter("YOUR_API_KEY");

// Or with configuration
builder.Services.AddOpenRouter(options =>
{
    options.ApiKey = builder.Configuration["OpenRouter:ApiKey"]!;
    options.BaseUrl = "https://openrouter.ai/api/v1";
    options.EnableRetry = true;
    options.MaxRetryAttempts = 3;
});

var app = builder.Build();
```

--------------------------------

### Initializing OpenRouterClient (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This C# code provides examples for initializing the `OpenRouterClient`. It demonstrates a simple initialization with just an API key and a more advanced initialization that configures additional options like `Timeout` and `MaxRetryAttempts` using an action.

```C#
// Simple initialization
var client = new OpenRouterClient("your-api-key");

// With configuration
var client = new OpenRouterClient("your-api-key", options => 
{
    options.Timeout = TimeSpan.FromSeconds(60);
    options.MaxRetryAttempts = 3;
});
```

--------------------------------

### Configuring OpenRouter Options in appsettings.json (JSON)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/getting-started.md

This JSON snippet shows how to configure OpenRouter API settings, including the API key, base URL, timeout, and retry options, within an appsettings.json file, typically used in ASP.NET Core applications.

```json
{
  "OpenRouter": {
    "ApiKey": "your_api_key_here",
    "BaseUrl": "https://openrouter.ai/api/v1",
    "Timeout": "00:00:30",
    "EnableRetry": true,
    "MaxRetryAttempts": 3
  }
}
```

--------------------------------

### Implementing Tool Calling - OpenRouter Chat API - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/chat-examples.md

This C# example demonstrates how to integrate tool calling with the OpenRouter chat completion API. It defines a `get_current_weather` function, handles user messages by invoking the appropriate tool, and processes the tool's output to generate a final AI response. It requires the `OpenRouter.Core` library and a `WeatherService` dependency for external API interaction.

```csharp
using OpenRouter.Core;
using OpenRouter.Models.Common;
using System.Text.Json;

public class WeatherAssistant
{
    private readonly IOpenRouterClient _client;
    private readonly WeatherService _weatherService;

    public WeatherAssistant(IOOpenRouterClient client, WeatherService weatherService)
    {
        _client = client;
        _weatherService = weatherService;
    }

    public async Task<string> GetWeatherResponseAsync(string userMessage)
    {
        // Define available tools
        var tools = new[]
        {
            new ToolDefinition
            {
                Type = "function",
                Function = new FunctionDefinition
                {
                    Name = "get_current_weather",
                    Description = "Get the current weather in a given location",
                    Parameters = JsonSerializer.Deserialize<JsonElement>("""
                    {
                        "type": "object",
                        "properties": {
                            "location": {
                                "type": "string",
                                "description": "The city and state, e.g. San Francisco, CA"
                            },
                            "unit": {
                                "type": "string",
                                "enum": ["celsius", "fahrenheit"],
                                "description": "Temperature unit"
                            }
                        },
                        "required": ["location"]
                    }
                    """)
                }
            }
        };

        var response = await _client.Chat
            .CreateChatCompletion("gpt-3.5-turbo")
            .AddSystemMessage("You are a helpful weather assistant. Use the provided tools to get current weather information.")
            .AddUserMessage(userMessage)
            .WithTools(tools)
            .WithToolChoice("auto")
            .SendAsync();

        var choice = response.Choices.FirstOrDefault();
        if (choice?.Message?.ToolCalls?.Any() == true)
        {
            var toolResults = new List<Message>();

            // Execute tool calls
            foreach (var toolCall in choice.Message.ToolCalls)
            {
                if (toolCall.Function?.Name == "get_current_weather")
                {
                    var args = JsonSerializer.Deserialize<WeatherRequest>(toolCall.Function.Arguments);
                    var weather = await _weatherService.GetWeatherAsync(args.Location, args.Unit ?? "celsius");
                    
                    toolResults.Add(new Message
                    {
                        Role = "tool",
                        ToolCallId = toolCall.Id,
                        Content = JsonSerializer.Serialize(weather)
                    });
                }
            }

            // Get final response with tool results
            var finalResponse = await _client.Chat
                .CreateChatCompletion("gpt-3.5-turbo")
                .AddSystemMessage("You are a helpful weather assistant.")
                .AddUserMessage(userMessage)
                .AddMessage(choice.Message)  // Original assistant response with tool calls
                .WithMessages(toolResults.ToArray())  // Tool results
                .SendAsync();

            return finalResponse.FirstChoiceContent;
        }

        return response.FirstChoiceContent;
    }
}

public class WeatherRequest
{
    public string Location { get; set; } = string.Empty;
    public string? Unit { get; set; }
}

public class WeatherService
{
    public async Task<object> GetWeatherAsync(string location, string unit)
    {
        // Mock implementation
        await Task.Delay(100);
        return new 
        {
            location,
            temperature = unit == "fahrenheit" ? 72 : 22,
            unit,
            description = "Sunny",
            humidity = 45
        };
    }
}
```

--------------------------------

### Installing OpenRouter .NET via NuGet (PowerShell)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/index.md

This PowerShell command installs the OpenRouter .NET library into your project using the NuGet Package Manager Console, simplifying dependency management.

```powershell
Install-Package OpenRouter
```

--------------------------------

### Configuring Model Behavior with System Messages in OpenRouter .NET

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/chat-examples.md

This example shows how to use system messages with the OpenRouter .NET library to configure the model's behavior and create specialized AI assistants. System prompts ensure consistent responses and improve quality for specific domains, enabling role-specific AI.

```C#
using OpenRouter.Core;

public class SpecializedAssistant
{
    private readonly IOpenRouterClient _client;
    private readonly string _systemPrompt;

    public SpecializedAssistant(IOpenRouterClient client, string systemPrompt)
    {
        _client = client;
        _systemPrompt = systemPrompt;
    }

    public async Task<string> GetResponseAsync(string userQuery)
    {
        var response = await _client.Chat
            .CreateChatCompletion("anthropic/claude-3-haiku")
            .AddSystemMessage(_systemPrompt)
            .AddUserMessage(userQuery)
            .WithTemperature(0.3) // Lower temperature for consistent behavior
            .SendAsync();

        return response.FirstChoiceContent;
    }
}

// Specialized assistants
var codeAssistant = new SpecializedAssistant(client, 
    "You are an expert C# programmer. Provide clean, maintainable code examples with explanations.");

var customerService = new SpecializedAssistant(client,
    "You are a friendly customer service representative. Be helpful, polite, and solution-oriented.");

var technicalWriter = new SpecializedAssistant(client,
    "You are a technical documentation expert. Write clear, concise documentation with proper formatting.");

// Usage
var codeExample = await codeAssistant.GetResponseAsync("Show me how to implement the repository pattern");
var serviceResponse = await customerService.GetResponseAsync("I'm having trouble with my order");
var documentation = await technicalWriter.GetResponseAsync("Document this API endpoint");
```

--------------------------------

### Managing Multi-Turn Conversations with OpenRouter .NET

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/chat-examples.md

This C# example illustrates how to build and maintain conversational context across multiple message exchanges using the OpenRouter .NET library. It's essential for chatbots and virtual assistants that require stateful interactions, though token usage increases with conversation length.

```C#
using OpenRouter.Core;
using OpenRouter.Models.Common;

public class ConversationManager
{
    private readonly IOpenRouterClient _client;
    private readonly List<Message> _conversationHistory;

    public ConversationManager(IOpenRouterClient client)
    {
        _client = client;
        _conversationHistory = new List<Message>();
    }

    public async Task<string> SendMessageAsync(string userMessage, string model = "anthropic/claude-3-haiku")
    {
        // Add user message to history
        _conversationHistory.Add(new Message 
        {
            Role = "user", 
            Content = userMessage 
        });

        var response = await _client.Chat
            .CreateChatCompletion(model)
            .WithMessages(_conversationHistory.ToArray())
            .WithTemperature(0.7)
            .SendAsync();

        var assistantMessage = response.FirstChoiceContent;

        // Add assistant response to history
        _conversationHistory.Add(new Message 
        {
            Role = "assistant", 
            Content = assistantMessage 
        });

        return assistantMessage;
    }

    public void ClearHistory() => _conversationHistory.Clear();

    public int GetHistoryLength() => _conversationHistory.Count;
}

// Usage example
var conversationManager = new ConversationManager(client);

var response1 = await conversationManager.SendMessageAsync("My name is Alice");
Console.WriteLine(response1); // "Nice to meet you, Alice!"

var response2 = await conversationManager.SendMessageAsync("What's my name?");
Console.WriteLine(response2); // "Your name is Alice."
```

--------------------------------

### Initializing OpenRouterClient with API Key (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Demonstrates the simplest way to initialize the OpenRouterClient by directly passing the API key to its constructor. This method is suitable for quick setups but is not recommended for production environments due to security concerns.

```C#
var client = new OpenRouterClient("your_api_key_here");
```

--------------------------------

### Example Chat Completion Request Initialization (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Demonstrates how to instantiate and populate a `ChatCompletionRequest` object. This example sets the model, defines system and user messages, and configures generation parameters like temperature and maximum tokens for a typical chat interaction.

```C#
var request = new ChatCompletionRequest
{
    Model = "gpt-4",
    Messages = new[]
    {
        Message.System("You are a helpful assistant."),
        Message.User("Explain quantum computing")
    },
    Temperature = 0.7,
    MaxTokens = 1000
};
```

--------------------------------

### Handling Chat Completion Response Properties (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/getting-started.md

This C# snippet illustrates how to access and process various properties of the ChatCompletionResponse object, including response ID, creation timestamp, model, individual choices, finish reasons, completion status, and detailed token usage information.

```csharp
var response = await client.Chat
    .CreateChatCompletion("gpt-3.5-turbo")
    .AddUserMessage("Tell me a joke")
    .SendAsync();

// Access response properties
Console.WriteLine($"Response ID: {response.Id}");
Console.WriteLine($"Created: {response.CreatedAt}");
Console.WriteLine($"Model: {response.Model}");

// Access choices
foreach (var choice in response.Choices)
{
    Console.WriteLine($"Choice {choice.Index}: {choice.Message?.Content}");
    Console.WriteLine($"Finish Reason: {choice.FinishReason}");
    
    // Check completion status
    if (choice.IsCompleted)
    {
        Console.WriteLine("Response completed successfully");
    }
}

// Usage information
if (response.Usage != null)
{
    Console.WriteLine($"Prompt tokens: {response.Usage.PromptTokens}");
    Console.WriteLine($"Completion tokens: {response.Usage.CompletionTokens}");
    Console.WriteLine($"Total tokens: {response.Usage.TotalTokens}");
}
```

--------------------------------

### Creating Single Message Chat Completion with OpenRouter .NET

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/chat-examples.md

This example demonstrates the simplest form of chat completion using the OpenRouter .NET library to send a single user message. It's ideal for basic Q&A scenarios, offering minimal token usage and fast response times due to its simple context.

```C#
using OpenRouter.Core;

var client = new OpenRouterClient("your-api-key");

var response = await client.Chat
    .CreateChatCompletion("gpt-3.5-turbo")
    .AddUserMessage("What is the capital of France?")
    .SendAsync();

Console.WriteLine(response.FirstChoiceContent); // "The capital of France is Paris."
```

--------------------------------

### Example Message Creation Patterns (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Illustrates various ways to create `Message` objects using the static factory methods. Examples include simple text messages, multi-modal messages with images, and messages representing tool responses, showcasing the flexibility of the `Message` model.

```C#
// Simple text messages
var systemMsg = Message.System("You are a helpful assistant.");
var userMsg = Message.User("Hello, how are you?");

// Multi-modal message with image
var multiModalMsg = Message.User(new[]
{
    MessageContent.CreateText("What do you see in this image?"),
    MessageContent.Image("https://example.com/image.jpg", "high")
});

// Tool response message
var toolMsg = Message.Tool("Weather is 72Â°F", "call_weather_123");
```

--------------------------------

### Dynamically Building Chat Requests in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/chat-examples.md

This example illustrates how to build chat completion requests dynamically based on runtime conditions such as user type, content requirements, or conversation context. It showcases conditional addition of system messages and conversation history, and adaptive parameter adjustments (e.g., temperature, max tokens) based on content type. It also includes user-specific adjustments and safety constraints, demonstrating a flexible approach to AI interaction.

```C#
using OpenRouter.Core;

public class AdaptiveChatService
{
    private readonly IOpenRouterClient _client;

    public AdaptiveChatService(IOpenRouterClient client)
    {
        _client = client;
    }

    public async Task<string> GetAdaptiveResponseAsync(
        string message, 
        ChatContext context)
    {
        var builder = _client.Chat.CreateChatCompletion(context.Model);
        
        // Conditional system message
        if (!string.IsNullOrEmpty(context.SystemPrompt))
        {
            builder = builder.AddSystemMessage(context.SystemPrompt);
        }

        // Add conversation history if available
        if (context.ConversationHistory?.Any() == true)
        {
            builder = builder.WithMessages(context.ConversationHistory);
        }

        builder = builder.AddUserMessage(message);

        // Conditional parameters based on content type
        builder = context.ContentType switch
        {
            ContentType.Creative => builder
                .WithTemperature(0.9)
                .WithTopP(0.95)
                .WithFrequencyPenalty(0.6),
                
            ContentType.Technical => builder
                .WithTemperature(0.1)
                .WithTopP(0.9)
                .WithMaxTokens(800),
                
            ContentType.Conversational => builder
                .WithTemperature(0.7)
                .WithTopK(40)
                .WithPresencePenalty(0.3),
                
            _ => builder.WithTemperature(0.5)
        };

        // User-specific adjustments
        if (context.User?.IsPremium == true)
        {
            builder = builder.WithMaxTokens(1000);
        }

        // Safety constraints for sensitive content
        if (context.RequiresModeration)
        {
            builder = builder
                .WithTemperature(0.3)
                .WithStop(new[] { "[INAPPROPRIATE]", "[HARMFUL]" });
        }

        var response = await builder.SendAsync();
        return response.FirstChoiceContent;
    }
}

public class ChatContext
{
    public string Model { get; set; } = "gpt-3.5-turbo";
    public string? SystemPrompt { get; set; }
    public Message[]? ConversationHistory { get; set; }
    public ContentType ContentType { get; set; } = ContentType.Conversational;
    public User? User { get; set; }
    public bool RequiresModeration { get; set; }
}

public enum ContentType
{
    Conversational,
    Technical,
    Creative,
    Educational
}

public class User
{
    public bool IsPremium { get; set; }
    public string? PreferredModel { get; set; }
}
```

--------------------------------

### Generating Structured JSON Output with OpenRouter in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/chat-examples.md

This C# code defines a `StructuredOutputService` that uses the OpenRouter API to generate JSON responses conforming to a specified schema. It includes example C# classes (`PersonInfo`, `ProductReview`) for deserializing the structured output and demonstrates how to extract information from a prompt into a `PersonInfo` object using a JSON schema.

```csharp
using OpenRouter.Core;
using System.Text.Json;

public class StructuredOutputService
{
    private readonly IOpenRouterClient _client;

    public StructuredOutputService(IOpenRouterClient client)
    {
        _client = client;
    }

    public async Task<T> GetStructuredResponseAsync<T>(string prompt, string jsonSchema)
    {
        var systemPrompt = """
        You are an expert data extraction assistant. 
        Extract information from the user's input and respond with valid JSON that matches this schema:
        
        {jsonSchema}
        
        Respond only with valid JSON, no additional text.
        """;

        var response = await _client.Chat
            .CreateChatCompletion("gpt-3.5-turbo")
            .AddSystemMessage(systemPrompt)
            .AddUserMessage(prompt)
            .WithTemperature(0.1)  // Low temperature for consistency
            .WithMaxTokens(500)
            .SendAsync();

        var jsonContent = response.FirstChoiceContent;
        return JsonSerializer.Deserialize<T>(jsonContent)!;
    }
}

// Usage examples
public class PersonInfo
{
    public string Name { get; set; } = string.Empty;
    public int Age { get; set; }
    public string Email { get; set; } = string.Empty;
    public string[] Skills { get; set; } = Array.Empty<string>();
}

public class ProductReview
{
    public string ProductName { get; set; } = string.Empty;
    public int Rating { get; set; }
    public string[] PositiveAspects { get; set; } = Array.Empty<string>();
    public string[] NegativeAspects { get; set; } = Array.Empty<string>();
    public string Summary { get; set; } = string.Empty;
}

// Usage
var service = new StructuredOutputService(client);

var personSchema = """
{
    "type": "object",
    "properties": {
        "name": {"type": "string"},
        "age": {"type": "integer"},
        "email": {"type": "string"},
        "skills": {"type": "array", "items": {"type": "string"}}
    },
    "required": ["name", "age", "email"]
}
""";

var person = await service.GetStructuredResponseAsync<PersonInfo>(
    "Extract info: John Doe is 30 years old, email john@example.com, knows C# and Python",
    personSchema
);

Console.WriteLine($"Name: {person.Name}, Age: {person.Age}");
```

--------------------------------

### Using OpenRouter Credits Service - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This C# example illustrates how to use the `ICreditsService` to manage account credits. It demonstrates checking the current credit balance, retrieving usage statistics, and initiating a Coinbase payment for additional credits using a `CoinbasePaymentRequest`.

```csharp
// Check current credits
var credits = await client.Credits.GetCreditsAsync();
Console.WriteLine($"Available credits: {credits.Credits}");

// Get usage statistics
var usage = await client.Credits.GetUsageAsync();

// Create payment for additional credits
var paymentRequest = new CoinbasePaymentRequest
{
    Amount = 10.00m,
    Currency = "USD"
};
var payment = await client.Credits.CreateCoinbasePaymentAsync(paymentRequest);
```

--------------------------------

### Implementing Advanced Console Streaming with Progress in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/streaming-examples.md

This C# class, `AdvancedConsoleStreaming`, demonstrates how to stream chat completions from an `IOpenRouterClient` while providing real-time progress updates directly in the console. It displays model and prompt information, tracks chunk count, character length, elapsed time, and calculates characters per second, enhancing user feedback and monitoring. It requires the `OpenRouter.Core` library and utilizes `System.Diagnostics` for timing.

```C#
using OpenRouter.Core;
using System.Diagnostics;

public class AdvancedConsoleStreaming
{
    private readonly IOpenRouterClient _client;

    public AdvancedConsoleStreaming(IOpenRouterClient client)
    {
        _client = client;
    }

    public async Task StreamWithProgressAsync(string prompt, string model = "gpt-3.5-turbo")
    {
        var stopwatch = Stopwatch.StartNew();
        var tokenCount = 0;
        var chunkCount = 0;
        var completeResponse = new StringBuilder();

        Console.Clear();
        Console.WriteLine($"Model: {model}");
        Console.WriteLine($"Prompt: {prompt}");
        Console.WriteLine(new string('=', 80));
        Console.WriteLine();

        // Reserve space for progress info
        var responseStartLine = Console.CursorTop;
        Console.WriteLine();
        Console.WriteLine();
        var statsLine = Console.CursorTop;

        try
        {
            await foreach (var chunk in _client.Chat
                .CreateStreamingChatCompletion(model)
                .AddUserMessage(prompt)
                .WithTemperature(0.7)
                .StreamAsync())
            {
                chunkCount++;

                if (chunk.Choices?.Any() == true)
                {
                    var deltaContent = chunk.Choices[0].Delta?.Content;
                    if (!string.IsNullOrEmpty(deltaContent))
                    {
                        // Update response area
                        var currentLine = Console.CursorTop;
                        Console.SetCursorPosition(0, responseStartLine);
                        
                        completeResponse.Append(deltaContent);
                        var responseText = completeResponse.ToString();
                        
                        // Word wrap for console
                        var wrappedText = WrapText(responseText, Console.WindowWidth - 2);
                        Console.Write(wrappedText);
                        
                        // Update statistics
                        Console.SetCursorPosition(0, statsLine);
                        Console.WriteLine($"Chunks: {chunkCount} | Characters: {responseText.Length} | Time: {stopwatch.Elapsed.TotalSeconds:F1}s");
                        Console.WriteLine($"Speed: {responseText.Length / Math.Max(stopwatch.Elapsed.TotalSeconds, 0.1):F1} chars/sec");
                    }

                    // Check for completion
                    if (chunk.Choices[0].FinishReason != null)
                    {
                        Console.SetCursorPosition(0, statsLine + 3);
                        Console.WriteLine($"âœ… Completed: {chunk.Choices[0].FinishReason}");
                        Console.WriteLine($"ðŸ“Š Final Stats - Chunks: {chunkCount}, Time: {stopwatch.Elapsed.TotalSeconds:F2}s");
                        break;
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.SetCursorPosition(0, statsLine + 3);
            Console.WriteLine($"âŒ Error: {ex.Message}");
        }
        finally
        {
            stopwatch.Stop();
        }
    }

    private static string WrapText(string text, int maxWidth)
    {
        var words = text.Split(' ');
        var lines = new List<string>();
        var currentLine = new StringBuilder();

        foreach (var word in words)
        {
            if (currentLine.Length + word.Length + 1 > maxWidth)
            {
                if (currentLine.Length > 0)
                {
                    lines.Add(currentLine.ToString());
                    currentLine.Clear();
                }
            }
            
            if (currentLine.Length > 0)
                currentLine.Append(" ");
            currentLine.Append(word);
        }

        if (currentLine.Length > 0)
            lines.Add(currentLine.ToString());

        return string.Join(Environment.NewLine, lines);
    }
}
```

--------------------------------

### Streaming OpenRouter Chat Responses to Console (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/streaming-examples.md

This C# example demonstrates how to stream real-time chat completion responses from the OpenRouter API directly to the console. It uses `IAsyncEnumerable` to process chunks as they arrive, accumulates the full response using `StringBuilder`, and includes robust error handling for `OpenRouterException` and general exceptions. It also shows how to detect stream completion using `FinishReason`.

```csharp
using OpenRouter.Core;
using OpenRouter.Models.Streaming;

public class ConsoleStreamingExample
{
    private readonly IOpenRouterClient _client;

    public ConsoleStreamingExample(IOpenRouterClient client)
    {
        _client = client;
    }

    public async Task StreamToConsoleAsync(string prompt)
    {
        Console.WriteLine("AI Response:");
        Console.WriteLine(new string('-', 50));

        try
        {
            var streamingRequest = _client.Chat
                .CreateStreamingChatCompletion("gpt-3.5-turbo")
                .AddUserMessage(prompt)
                .WithTemperature(0.7);

            var completeResponse = new StringBuilder();

            await foreach (var chunk in streamingRequest.StreamAsync())
            {
                if (chunk.Choices?.Any() == true)
                {
                    var deltaContent = chunk.Choices[0].Delta?.Content;
                    if (!string.IsNullOrEmpty(deltaContent))
                    {
                        Console.Write(deltaContent);
                        completeResponse.Append(deltaContent);
                    }
                }

                // Handle completion
                if (chunk.Choices?[0].FinishReason != null)
                {
                    Console.WriteLine("\n" + new string('-', 50));
                    Console.WriteLine($"Stream completed. Reason: {chunk.Choices[0].FinishReason}");
                    break;
                }
            }

            Console.WriteLine($"\nComplete response length: {completeResponse.Length} characters");
        }
        catch (OpenRouterException ex)
        {
            Console.WriteLine($"\nStreaming error: {ex.Message}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"\nUnexpected error: {ex.Message}");
        }
    }
}

// Usage
var streamingExample = new ConsoleStreamingExample(client);
await streamingExample.StreamToConsoleAsync("Write a short story about a robot learning to feel emotions.");
```

--------------------------------

### Performing Basic Chat Completion with OpenRouter .NET (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/index.md

This C# example initializes an OpenRouterClient with an API key, creates a chat completion request for 'gpt-3.5-turbo' with a user message, sends it asynchronously, and prints the first choice content from the AI's response. It demonstrates the fluent API for chat completions.

```csharp
// Simple client initialization
var client = new OpenRouterClient("YOUR_API_KEY");

// Your first chat completion
var response = await client.Chat
    .CreateChatCompletion("gpt-3.5-turbo")
    .AddUserMessage("Hello, world!")
    .SendAsync();

Console.WriteLine(response.FirstChoiceContent);
```

--------------------------------

### Example AuthRequest Model Initialization in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Demonstrates the structure and initialization of an AuthRequest object used in the OpenRouter OAuth flow. It specifies ClientId, RedirectUri, Scopes, and State parameters for an authorization request.

```csharp
var authRequest = new AuthRequest
{
    ClientId = "your_client_id",
    RedirectUri = "https://your-app.com/oauth/callback",
    Scopes = new[] { "read", "write" },
    State = "random_state_value"
};
```

--------------------------------

### Using OpenRouter Model Service - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This C# example demonstrates how to interact with the `IModelsService` to perform common model-related tasks. It shows how to list all available models, retrieve details for a specific model like 'openai/gpt-4', and filter models by provider using a `ModelsRequest` object.

```csharp
// List all models
var allModels = await client.Models.ListModelsAsync();

// Get specific model details
var gpt4Details = await client.Models.GetModelAsync("openai/gpt-4");

// Get models with filtering
var modelsRequest = new ModelsRequest { Provider = "openai" };
var openAIModels = await client.Models.GetModelsAsync(modelsRequest);
```

--------------------------------

### Implementing OAuth PKCE Flow in ASP.NET Core C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Provides a complete ASP.NET Core controller example for implementing the OAuth PKCE (Proof Key for Code Exchange) flow. It includes methods for initiating the authorization request and handling the callback, demonstrating code verifier generation, state management, and token exchange.

```csharp
public class OAuthController : ControllerBase
{
    private readonly IOpenRouterClient _client;

    public OAuthController(IOpenRouterClient client)
    {
        _client = client;
    }

    [HttpGet("authorize")]
    public async Task<IActionResult> Authorize()
    {
        // Generate PKCE parameters
        var codeVerifier = GenerateCodeVerifier();
        var codeChallenge = GenerateCodeChallenge(codeVerifier);
        var state = GenerateState();

        // Store verifier and state in session/cache
        HttpContext.Session.SetString("code_verifier", codeVerifier);
        HttpContext.Session.SetString("oauth_state", state);

        // Generate authorization URL
        var authUrl = await _client.Auth.GenerateAuthorizationUrlAsync(
            clientId: "your_client_id",
            redirectUri: "https://your-app.com/oauth/callback",
            scopes: new[] { "read", "write" },
            state: state
        );

        return Redirect(authUrl);
    }

    [HttpGet("callback")]
    public async Task<IActionResult> Callback(string code, string state)
    {
        // Validate state parameter
        var storedState = HttpContext.Session.GetString("oauth_state");
        if (state != storedState)
        {
            return BadRequest("Invalid state parameter");
        }

        // Retrieve code verifier
        var codeVerifier = HttpContext.Session.GetString("code_verifier");
        if (string.IsNullOrEmpty(codeVerifier))
        {
            return BadRequest("Code verifier not found");
        }

        try
        {
            // Exchange authorization code for tokens
            var tokenResponse = await _client.Auth.ExchangeCodeForTokenAsync(
                code: code,
                clientId: "your_client_id",
                redirectUri: "https://your-app.com/oauth/callback",
                codeVerifier: codeVerifier
            );

            // Store tokens securely
            // ... implement token storage logic ...

            return Ok(new { message = "Authentication successful" });
        }
        catch (OpenRouterException ex)
        {
            return BadRequest(new { error = ex.Message });
        }
    }
}
```

--------------------------------

### Configuring OpenRouter Services with Options (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This example shows how to use `AddOpenRouter(Action<OpenRouterOptions>)` for advanced configuration. It allows setting various options like API key, base URL, timeout, retry logic, logging, and validation, providing fine-grained control over the OpenRouter client's behavior.

```C#
builder.Services.AddOpenRouter(options =>
{
    options.ApiKey = builder.Configuration["OpenRouter:ApiKey"]!;
    options.BaseUrl = "https://openrouter.ai/api/v1";
    options.Timeout = TimeSpan.FromSeconds(30);
    options.EnableRetry = true;
    options.MaxRetryAttempts = 3;
    options.RetryDelay = TimeSpan.FromSeconds(1);
    options.EnableLogging = true;
    options.LogLevel = LogLevel.Information;
    options.ValidateApiKey = true;
    options.ThrowOnApiErrors = true;
});
```

--------------------------------

### Configuring Flexible Authentication Providers in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Shows how to configure different IAuthenticationProvider implementations using dependency injection in C#. It provides examples for setting up BearerTokenProvider (for API Key authentication) and OAuthTokenProvider (for OAuth token authentication), demonstrating flexible authentication scheme management.

```csharp
// API Key Authentication
services.AddSingleton<IAuthenticationProvider>(provider =>
{
    var options = provider.GetRequiredService<OpenRouterOptions>();
    return new BearerTokenProvider(options.ApiKey, options.ValidateApiKey);
});

// OAuth Token Authentication
services.AddSingleton<IAuthenticationProvider>(provider =>
{
    var tokenStore = provider.GetRequiredService<ITokenStore>();
    return new OAuthTokenProvider(tokenStore);
});
```

--------------------------------

### Adding OpenRouter Library as Project Reference - XML

Source: https://github.com/xyoz-dev/openrouter/blob/master/README.md

This snippet shows how to add a project reference to the OpenRouter library in a .NET project's .csproj file. This is an alternative installation method for integrating the library into an existing solution.

```XML
<ProjectReference Include="path/to/OpenRouter/OpenRouter.csproj" />
```

--------------------------------

### Managing API Keys Across Multiple Environments (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/api-keys.md

This C# class provides a basic example of managing API keys for different deployment environments (development, staging, production) using a dictionary. It includes a method to retrieve the appropriate key based on the specified environment, illustrating a simple multi-environment key management pattern.

```csharp
public class EnvironmentKeyManager
{
    private readonly Dictionary<string, string> _environmentKeys = new()
    {
        { "development", "dev-key" },
        { "staging", "staging-key" },
        { "production", "prod-key" }
    };

    public string GetKeyForEnvironment(string environment)
    {
        return _environmentKeys[environment];
    }
}
```

--------------------------------

### Integrating Web Search with OpenRouter Chat Completions in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/chat-examples.md

This C# code demonstrates a `WebSearchChatService` that integrates real-time web search with OpenRouter's chat completion API. It intelligently decides whether to perform a web search based on the user's query, fetches results using an `IWebSearchService`, and then injects these results as context into the chat completion prompt to generate an informed and up-to-date response. It also includes helper methods for direct responses and formatting search results.

```C#
using OpenRouter.Core;

public class WebSearchChatService
{
    private readonly IOpenRouterClient _client;
    private readonly IWebSearchService _webSearch;

    public WebSearchChatService(IOpenRouterClient client, IWebSearchService webSearch)
    {
        _client = client;
        _webSearch = webSearch;
    }

    public async Task<string> GetInformedResponseAsync(string query)
    {
        // Determine if web search is needed
        var needsSearch = await ShouldPerformSearchAsync(query);
        
        if (!needsSearch)
        {
            // Direct response without search
            return await GetDirectResponseAsync(query);
        }

        // Perform web search
        var searchResults = await _webSearch.SearchAsync(query, maxResults: 5);
        
        // Combine search results with chat
        var context = FormatSearchContext(searchResults);
        
        var response = await _client.Chat
            .CreateChatCompletion("gpt-3.5-turbo")
            .AddSystemMessage("You are a helpful assistant. Use the provided search results to give accurate, up-to-date information. Cite sources when relevant.")
            .AddUserMessage($"Context from web search:\n{context}\n\nUser question: {query}")
            .WithTemperature(0.3)
            .WithMaxTokens(800)
            .SendAsync();

        return response.FirstChoiceContent;
    }

    private async Task<bool> ShouldPerformSearchAsync(string query)
    {
        var response = await _client.Chat
            .CreateChatCompletion("gpt-3.5-turbo")
            .AddSystemMessage("Determine if this query requires current information from the web. Respond with only 'YES' or 'NO'.")
            .AddUserMessage($"Query: {query}")
            .WithTemperature(0.1)
            .WithMaxTokens(10)
            .SendAsync();

        return response.FirstChoiceContent.Trim().ToUpper() == "YES";
    }

    private async Task<string> GetDirectResponseAsync(string query)
    {
        var response = await _client.Chat
            .CreateChatCompletion("gpt-3.5-turbo")
            .AddUserMessage(query)
            .WithTemperature(0.7)
            .SendAsync();

        return response.FirstChoiceContent;
    }

    private static string FormatSearchContext(IEnumerable<SearchResult> results)
    {
        return string.Join("\n\n", results.Select((result, index) => 
            $"[Source {index + 1}] {result.Title}\n{result.Snippet}\nURL: {result.Url}"));
    }
}

public interface IWebSearchService
{
    Task<IEnumerable<SearchResult>> SearchAsync(string query, int maxResults = 10);
}

public class SearchResult
{
    public string Title { get; set; } = string.Empty;
    public string Snippet { get; set; } = string.Empty;
    public string Url { get; set; } = string.Empty;
}
```

--------------------------------

### Basic Chat Service Usage in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This example demonstrates two ways to use the `IChatService`: a direct request approach for simple chat completions and a fluent builder approach using `IChatRequestBuilder` for more readable and configurable requests. Both methods achieve chat completion with a specified model and user message.

```C#
// Direct request approach
var request = new ChatCompletionRequest
{
    Model = "gpt-3.5-turbo",
    Messages = new[] { new Message { Role = "user", Content = "Hello!" } }
};
var response = await client.Chat.CreateAsync(request);

// Fluent builder approach
var response = await client.Chat
    .CreateRequest()
    .WithModel("gpt-3.5-turbo")
    .WithUserMessage("Hello!")
    .ExecuteAsync();
```

--------------------------------

### Implementing OpenRouter OAuth Authentication Flow (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This C# example demonstrates the complete OAuth authentication flow using the OpenRouter client, including PKCE. It shows how to generate a PKCE challenge, construct an authorization URL with client details, and then exchange the received authorization code for an API key after user consent. It requires an initialized `client` instance and `OAuthConfig`, `AuthKeyExchangeRequest` models.

```C#
// Generate PKCE challenge
var pkce = client.Auth.GeneratePKCEChallenge();

// Generate authorization URL
var authUrl = client.Auth.GenerateAuthorizationUrl(new OAuthConfig
{
    ClientId = "your-client-id",
    RedirectUri = "https://yourapp.com/callback",
    CodeChallenge = pkce.Challenge,
    CodeChallengeMethod = "S256"
});

// After user authorization, exchange code for key
var exchangeRequest = new AuthKeyExchangeRequest
{
    Code = "received-auth-code",
    CodeVerifier = pkce.Verifier
};
var authResponse = await client.Auth.ExchangeCodeForKeyAsync(exchangeRequest);
```

--------------------------------

### Handling Keyboard Input for Chat - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/streaming-examples.md

This method processes keyboard events, specifically checking for the 'Enter' key combined with the 'Ctrl' key. If this combination is detected and no streaming is currently active, it triggers the `SendMessageAsync` method to send the user's message.

```C#
private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && e.CtrlKey && !isStreaming)
        {
            await SendMessageAsync();
        }
    }
```

--------------------------------

### Configuring Advanced Chat Completion Parameters in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/chat-examples.md

This snippet demonstrates how to use the fluent `IChatRequestBuilder` to create a chat completion request with a comprehensive set of parameters. It shows how to add system and user messages, and configure generation settings like temperature, max tokens, top-p, top-k, frequency penalty, presence penalty, stop sequences, seed for reproducibility, and logit bias for term boosting. This allows for precise control over the AI's response generation.

```C#
using OpenRouter.Core;

// Advanced configuration with all parameters
var response = await client.Chat
    .CreateChatCompletion("anthropic/claude-3-haiku")
    .AddSystemMessage("You are a creative writing assistant specializing in science fiction.")
    .AddUserMessage("Write a short story about AI and humanity")
    .WithTemperature(0.9)           // High creativity
    .WithMaxTokens(500)             // Longer response
    .WithTopP(0.95)                 // Nucleus sampling
    .WithTopK(50)                   // Top-k sampling
    .WithFrequencyPenalty(0.6)      // Reduce repetition
    .WithPresencePenalty(0.5)       // Encourage new topics
    .WithStop(new[] { "\n\n---", "THE END" })  // Stop sequences
    .WithSeed(12345)                // Reproducible results
    .WithLogitBias(new Dictionary<string, double> 
    {
        ["science"] = 1.5,          // Boost science-related terms
        ["technology"] = 1.3 
    })
    .SendAsync();

Console.WriteLine(response.FirstChoiceContent);
```

--------------------------------

### Basic API Key Authentication with OpenRouter Client in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

This C# example demonstrates how to perform basic API key authentication using the `OpenRouterClient`. It initializes the client with a provided API key, sends a simple chat completion request, and prints the first choice content. A `try-catch` block is included to handle potential `OpenRouterException` for authentication or API errors.

```C#
// Basic setup for API key authentication
var client = new OpenRouterClient("your_api_key_here");

try
{
    var response = await client.Chat
        .CreateChatCompletion("gpt-3.5-turbo")
        .AddUserMessage("Hello!")
        .SendAsync();
    
    Console.WriteLine(response.FirstChoiceContent);
}
catch (OpenRouterException ex)
{
    Console.WriteLine($"Authentication or API error: {ex.Message}");
}
```

--------------------------------

### Creating New API Keys with Specific Permissions (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/api-keys.md

This example illustrates how to create a new API key using the KeysRequest model, specifying a name and an array of permissions. It then calls CreateKeyAsync to generate the key and prints the newly created key.

```csharp
var newKeyRequest = new KeysRequest
{
    Name = "Production API Key",
    Permissions = new[] { "chat", "models" }
};

var createdKey = await client.Keys.CreateKeyAsync(newKeyRequest);
Console.WriteLine($"New key created: {createdKey.Key}");
```

--------------------------------

### Setting Up OpenRouter .NET Development Environment

Source: https://github.com/xyoz-dev/openrouter/blob/master/README.md

This sequence of commands outlines the steps to set up the development environment for the OpenRouter .NET project. It includes cloning the repository, navigating into the directory, restoring NuGet packages, building the project, and running all tests.

```bash
git clone https://github.com/xyOz-dev/OpenRouter.git
cd OpenRouter
dotnet restore
dotnet build
dotnet test
```

--------------------------------

### Integrating Polly for HttpClient Resilience in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

This C# snippet demonstrates integrating Polly policies (retry, circuit breaker, timeout) with `HttpClient` for enhanced resilience. It includes a `GetRetryPolicy` example that handles unsuccessful HTTP responses and `HttpRequestException` with exponential backoff.

```csharp
services.AddHttpClient<IOpenRouterClient, OpenRouterClient>()
    .AddPolicyHandler(GetRetryPolicy())
    .AddPolicyHandler(GetCircuitBreakerPolicy())
    .AddPolicyHandler(GetTimeoutPolicy());

private static IAsyncPolicy<HttpResponseMessage> GetRetryPolicy()
{
    return Policy
        .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
        .Or<HttpRequestException>()
        .WaitAndRetryAsync(
            retryCount: 3,
            sleepDurationProvider: retryAttempt => 
                TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),
            onRetry: (outcome, timespan, retryCount, context) =>
            {
                Console.WriteLine($"Retry {retryCount} after {timespan} seconds");
            });
}
```

--------------------------------

### Monitoring OpenRouter Credit Balance and Usage in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/credits.md

This example illustrates how to fetch detailed credit information, including the current balance and daily usage, using the GetCreditsAsync() method. It then prints these values to the console, providing real-time insights into credit consumption.

```C#
var creditsResponse = await client.Credits.GetCreditsAsync();
Console.WriteLine($"Current balance: ${creditsResponse.Data.Balance}");
Console.WriteLine($"Credits used today: {creditsResponse.Data.Usage.Today}");
```

--------------------------------

### Formatting AI Response for Display - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/streaming-examples.md

This utility method applies simple markdown-like formatting to the AI's response string. It replaces newline characters (`\n`) with HTML break tags (`<br/>`) and converts double asterisks (`**`) into HTML strong tags (`<strong>`) for basic text bolding, enhancing readability in the UI.

```C#
private string FormatResponse(string response)
    {
        // Simple markdown-like formatting
        return response
            .Replace("\n", "<br/>")
            .Replace("**", "<strong>", StringComparison.OrdinalIgnoreCase)
            .Replace("**", "</strong>", StringComparison.OrdinalIgnoreCase);
    }
```

--------------------------------

### Selecting Models for Specific Use Cases (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/models.md

This example illustrates how to choose different OpenRouter models based on specific application requirements, such as 'anthropic/claude-3-haiku' for code generation or 'openai/gpt-4-turbo' for analysis tasks. It highlights the flexibility in model selection.

```csharp
// For code generation
var codeModel = "anthropic/claude-3-haiku";

// For creative writing
var creativeModel = "anthropic/claude-3-opus";

// For analysis tasks
var analyticsModel = "openai/gpt-4-turbo";
```

--------------------------------

### Initializing Chat State and Data Models - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/streaming-examples.md

This snippet defines the private fields for managing the chat component's state, including the current message, selected model, streaming response, and conversation history. It also declares nested classes, `ConversationExchange` for storing user messages and AI responses, and `StreamingStats` for tracking streaming performance metrics like chunks received and elapsed time.

```C#
private string currentMessage = string.Empty;
    private string selectedModel = "gpt-3.5-turbo";
    private string streamingResponse = string.Empty;
    private bool isStreaming = false;
    private List<ConversationExchange> conversationHistory = new();
    private CancellationTokenSource? cancellationTokenSource;
    private StreamingStats streamingStats = new();

    private class ConversationExchange
    {
        public required string UserMessage { get; set; }
        public required string AiResponse { get; set; }
        public DateTime Timestamp { get; set; } = DateTime.Now;
    }

    private class StreamingStats
    {
        public int ChunksReceived { get; set; }
        public DateTime StartTime { get; set; }
        public TimeSpan ElapsedTime => DateTime.Now - StartTime;
    }
```

--------------------------------

### Registering OpenRouter Services with API Key (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This snippet demonstrates the basic registration of OpenRouter services using `AddOpenRouter(string apiKey)`. It automatically registers core OpenRouter client and service interfaces as Scoped, along with authentication and HTTP client providers as Singleton, simplifying initial setup.

```C#
using OpenRouter.Extensions;

var builder = WebApplication.CreateBuilder(args);

// Simple registration with API key
builder.Services.AddOpenRouter("your_api_key_here");

var app = builder.Build();
```

--------------------------------

### Styling Chat UI Components - CSS

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/streaming-examples.md

This CSS snippet defines styles for various UI elements within the chat component. It includes rules for the streaming response area to ensure proper text wrapping and font styling, an animation for a blinking cursor, and general styles for card containers and disabled buttons to provide visual feedback.

```CSS
.streaming-response {
        min-height: 100px;
        white-space: pre-wrap;
        word-wrap: break-word;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.5;
    }

    .streaming-cursor {
        animation: blink 1s infinite;
        font-weight: bold;
    }

    @keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
    }

    .card {
        border: 1px solid #dee2e6;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .btn:disabled {
        opacity: 0.6;
    }
```

--------------------------------

### Implementing Real-time AI Chat Streaming in Blazor Server

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/streaming-examples.md

This Blazor Server component (.razor file) demonstrates a real-time AI chat interface. It uses IOpenRouterClient for streaming AI responses, updates the UI dynamically as chunks arrive, and manages user input, model selection, and conversation history. It also includes UI elements for sending messages, canceling streams, and displaying streaming statistics. Dependencies include OpenRouter.Core and IJSRuntime for JavaScript interop.

```Blazor
@page "/streaming-chat"\n@using OpenRouter.Core\n@inject IOpenRouterClient OpenRouterClient\n@inject IJSRuntime JSRuntime\n@implements IDisposable\n\n<PageTitle>Streaming Chat</PageTitle>\n\n<div class="container mt-4">\n    <div class="row">\n        <div class="col-12">\n            <h3>AI Streaming Chat</h3>\n            \n            <div class="card mb-3">\n                <div class="card-body">\n                    <div class="form-group mb-3">\n                        <label for="messageInput">Your Message:</label>\n                        <textarea @bind="currentMessage" \n                                 @onkeypress="HandleKeyPress"\n                                 class="form-control" \n                                 id="messageInput" \n                                 rows="3" \n                                 disabled="@isStreaming"\n                                 placeholder="Type your message here..."></textarea>\n                    </div>\n                    \n                    <div class="form-group mb-3">\n                        <label for="modelSelect">Model:</label>\n                        <select @bind="selectedModel" class="form-control" id="modelSelect" disabled="@isStreaming">\n                            <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>\n                            <option value="anthropic/claude-3-haiku">Claude 3 Haiku</option>\n                            <option value="meta-llama/llama-2-70b-chat">Llama 2 70B</option>\n                        </select>\n                    </div>\n                    \n                    <button @onclick="SendMessageAsync" \n                           class="btn btn-primary" \n                           disabled="@(isStreaming || string.IsNullOrWhiteSpace(currentMessage))">\n                        @if (isStreaming)\n                        {\n                            <span class="spinner-border spinner-border-sm me-2"></span>\n                            Thinking...\n                        }\n                        else\n                        {\n                            <i class="fas fa-paper-plane me-2"></i>\n                            Send Message\n                        }\n                    </button>\n                    \n                    @if (isStreaming)\n                    {\n                        <button @onclick="CancelStream" class="btn btn-secondary ms-2">\n                            <i class="fas fa-stop me-2"></i>\n                            Cancel\n                        </button>\n                    }\n                </div>\n            </div>\n\n            <div class="card">\n                <div class="card-header d-flex justify-content-between align-items-center">\n                    <h5 class="mb-0">AI Response</h5>\n                    @if (!string.IsNullOrEmpty(streamingResponse))\n                    {\n                        <small class="text-muted">\n                            @($" {streamingResponse.Length} characters â€¢ {streamingStats.ChunksReceived} chunks â€¢ {streamingStats.ElapsedTime.TotalSeconds:F1}s")\n                        </small>\n                    }\n                </div>\n                <div class="card-body">\n                    @if (string.IsNullOrEmpty(streamingResponse) && !isStreaming)\n                    {\n                        <p class="text-muted">AI response will appear here...</p>\n                    }\n                    else\n                    {\n                        <div class="streaming-response">\n                            @((MarkupString)FormatResponse(streamingResponse))\n                            @if (isStreaming)\n                            {\n                                <span class="streaming-cursor">|</span>\n                            }\n                        </div>\n                    }\n                </div>\n            </div>\n\n            @if (conversationHistory.Any())\n            {\n                <div class="card mt-3">\n                    <div class="card-header">\n                        <h5 class="mb-0">Conversation History</h5>\n                        <small class="text-muted">@conversationHistory.Count exchanges</small>\n                    </div>\n                    <div class="card-body">\n                        @foreach (var exchange in conversationHistory.TakeLast(3))\n                        {\n                            <div class="mb-3">\n                                <strong>You:</strong> @exchange.UserMessage<br />\n                                <strong>AI:</strong> @exchange.AiResponse.Substring(0, Math.Min(exchange.AiResponse.Length, 100))@(exchange.AiResponse.Length > 100 ? "..." : "")\n                            </div>\n                        }\n                    </div>\n                </div>\n            }\n        </div>\n    </div>\n</div>
```

--------------------------------

### Mocking OpenRouter Services for C# Unit Tests

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This C# unit test example demonstrates how to use Moq to create mock instances of IOpenRouterClient and IChatService for isolated testing. It sets up mock behaviors for method calls and registers these mocks with a ServiceCollection to simulate dependency injection in a test environment.

```C#
public class ChatControllerTests
{
    [Fact]
    public async Task CreateChatCompletion_WithValidRequest_ReturnsSuccess()
    {
        // Arrange
        var services = new ServiceCollection();
        
        var mockClient = new Mock<IOpenRouterClient>();
        var mockChatService = new Mock<IChatService>();
        
        mockClient.Setup(c => c.Chat).Returns(mockChatService.Object);
        mockChatService
            .Setup(c => c.CreateChatCompletion(It.IsAny<string>()))
            .Returns(new ChatRequestBuilder(mockClient.Object, "gpt-3.5-turbo"));

        services.AddSingleton(mockClient.Object);
        services.AddSingleton<ChatController>();

        var serviceProvider = services.BuildServiceProvider();
        var controller = serviceProvider.GetRequiredService<ChatController>();

        // Act & Assert
        var result = await controller.CreateChatCompletion(new ChatCompletionRequest 
        {
            Model = "gpt-3.5-turbo", 
            Message = "Test" 
        });

        // Verify results...
    }
}
```

--------------------------------

### Integrating OpenRouter in C# Background Services

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This C# BackgroundService example shows how to integrate the IOpenRouterClient within a long-running background process. It uses IServiceProvider.CreateScope() to resolve the client per execution cycle, ensuring proper dependency management and error handling for asynchronous chat request processing.

```C#
public class ChatProcessingService : BackgroundService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<ChatProcessingService> _logger;

    public ChatProcessingService(
        IServiceProvider serviceProvider,
        ILogger<ChatProcessingService> logger)
    {
        _serviceProvider = serviceProvider;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            using var scope = _serviceProvider.CreateScope();
            var openRouterClient = scope.ServiceProvider.GetRequiredService<IOpenRouterClient>();

            try
            {
                // Process chat requests from queue
                await ProcessChatRequestsAsync(openRouterClient, stoppingToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing chat requests");
            }

            await Task.Delay(TimeSpan.FromSeconds(10), stoppingToken);
        }
    }

    private async Task ProcessChatRequestsAsync(
        IOpenRouterClient client,
        CancellationToken cancellationToken)
    {
        // Implementation details...
    }
}

// Register background service
builder.Services.AddHostedService<ChatProcessingService>();
```

--------------------------------

### Registering ChatService as Transient in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This example demonstrates registering IChatService as Transient, meaning a new instance will be created every time it's requested. This is suitable for services that might hold state specific to a single operation or require fresh instances for each use, retrieving the IOpenRouterClient from the service provider.

```csharp
// Register as Transient if you need new instances each time
services.AddTransient<IChatService>(provider =>
{
    var client = provider.GetRequiredService<IOpenRouterClient>();
    return client.Chat;
});
```

--------------------------------

### Catching General OpenRouter Exceptions (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This example illustrates how to handle broader categories of OpenRouter exceptions. It provides a uniform approach for logging all API-related errors or catching any generic OpenRouter exception when specific handling is not required.

```csharp
try
{
    var response = await client.Chat.CreateAsync(request);
}
catch (OpenRouterApiException apiEx)
{
    // Handle all API-related exceptions
    Logger.LogError("API Error: {Message} (Status: {Status}, Code: {Code})", 
        apiEx.Message, apiEx.StatusCode, apiEx.ErrorCode);
}
catch (OpenRouterException ex)
{
    // Handle all OpenRouter exceptions
    Logger.LogError("OpenRouter Error: {Message}", ex.Message);
}
```

--------------------------------

### Configuring Tools with Fluent API in OpenRouter C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

This C# example illustrates using the fluent API for tool configuration with the OpenRouter chat client. Instead of passing a pre-built array, it uses a builder pattern within `WithTools()` to dynamically add tools (e.g., `AddWeatherTool()`, `AddCalculatorTool()`, `AddDatabaseTool()`), providing a more flexible and potentially more readable way to manage tool sets.

```C#
var response = await client.Chat
    .WithModel("claude-3-sonnet")
    .WithMessages(userMessage)
    .WithTools(builder =>
    {
        builder.AddWeatherTool();
        builder.AddCalculatorTool();
        builder.AddDatabaseTool();
    })
    .ExecuteAsync();
```

--------------------------------

### Comprehensive Chat Request Builder Usage in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This example demonstrates a comprehensive usage of the `IChatRequestBuilder` to construct a detailed chat completion request. It showcases configuring the model, system and user messages, generation parameters like temperature and max tokens, enabling web search, and requesting structured output, culminating in an asynchronous execution.

```C#
var response = await client.Chat
    .CreateRequest()
    .WithModel("gpt-4")
    .WithSystemMessage("You are a helpful assistant.")
    .WithUserMessage("Explain quantum computing")
    .WithTemperature(0.7)
    .WithMaxTokens(1000)
    .WithWebSearch(enabled: true)
    .WithStructuredOutput<ExplanationResponse>()
    .ExecuteAsync();
```

--------------------------------

### Insecure Hardcoded API Key (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Shows an example of an insecure practice where an API key is hardcoded directly into the source code. This method is explicitly discouraged due to significant security risks, including potential exposure of sensitive credentials.

```C#
var apiKey = "sk-or-..."; // DON'T DO THIS
```

--------------------------------

### Implementing Secure Token Storage (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/oauth.md

This snippet provides examples for securely storing tokens. It suggests using `ProtectedData.Protect` for general data protection or platform-specific secure storage mechanisms like `SecureStorage.SetAsync` (common in Xamarin/MAUI) to protect sensitive access tokens.

```C#
// Use secure storage mechanisms
var protectedData = ProtectedData.Protect(tokenData, entropy, DataProtectionScope.CurrentUser);

// Or use platform-specific secure storage
await SecureStorage.SetAsync("access_token", accessToken);
```

--------------------------------

### Configuring Advanced Web Search Options in OpenRouter .NET

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

This example illustrates how to use the `WithWebSearch(Action<WebSearchOptions>)` method to apply comprehensive custom configurations to web searches. It allows granular control over parameters like `MaxResults`, `TimeRange`, `AllowedDomains`, `SearchSafety`, `IncludeCitations`, `RankBy`, and `ContentType` for tailored search behavior.

```C#
var response = await client.Chat
    .WithModel("claude-3-sonnet")
    .WithMessages("Research the financial performance of tech companies in 2024")
    .WithWebSearch(options =>
    {
        options.MaxResults = 15;
        options.TimeRange = TimeRange.LastYear;
        options.AllowedDomains = new[] { "sec.gov", "nasdaq.com", "bloomberg.com", "reuters.com" };
        options.SearchSafety = SearchSafety.Strict;
        options.IncludeCitations = true;
        options.RankBy = SearchRanking.Relevance;
        options.ContentType = ContentType.Articles;
    })
    .ExecuteAsync();
```

--------------------------------

### Defining API Key Permissions for Different Roles (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/api-keys.md

This example shows how to define KeysRequest objects with different sets of permissions for distinct use cases, such as a read-only key for monitoring and a full-access key for production operations, illustrating granular access control.

```csharp
// Read-only key for monitoring
var monitoringKey = new KeysRequest
{
    Name = "Monitoring Key",
    Permissions = new[] { "models:read", "credits:read" }
};

// Full access key for production
var productionKey = new KeysRequest
{
    Name = "Production Key",
    Permissions = new[] { "chat", "models", "credits", "keys" }
};
```

--------------------------------

### Defining a Complex Database Query Tool in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

This C# example illustrates defining a `Tool` for executing database queries with a more complex parameter schema. It includes parameters for 'table' (required string), 'filters' (an array of objects with 'field', 'operator', and 'value'), and an optional 'limit' with min/max constraints and a default value, showcasing advanced schema definition.

```C#
var databaseQueryTool = new Tool
{
    Function = new Function
    {
        Name = "query_database",
        Description = "Execute a database query with filters and sorting",
        Parameters = new
        {
            type = "object",
            properties = new
            {
                table = new
                {
                    type = "string",
                    description = "Database table name"
                },
                filters = new
                {
                    type = "array",
                    items = new
                    {
                        type = "object",
                        properties = new
                        {
                            field = new { type = "string" },
                            @operator = new { type = "string", @enum = new[] { "eq", "gt", "lt", "contains" } },
                            value = new { type = "string" }
                        },
                        required = new[] { "field", "operator", "value" }
                    }
                },
                limit = new
                {
                    type = "integer",
                    minimum = 1,
                    maximum = 1000,
                    @default = 10
                }
            },
            required = new[] { "table" }
        }
    }
};
```

--------------------------------

### Implementing Streaming Chat Client in JavaScript

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/streaming-examples.md

This JavaScript class, `StreamingChatClient`, provides functionality to connect to a streaming chat API endpoint and process Server-Sent Events (SSE). It uses the Fetch API to make a POST request and an async generator (`Symbol.asyncIterator`) to yield parsed data chunks in real-time, suitable for dynamic UI updates. The `displayStreamingResponse` function demonstrates how to consume this stream and update a DOM element.

```javascript
// Frontend JavaScript for consuming the streaming API
class StreamingChatClient {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
    }

    async streamChat(message, options = {}) {
        const requestBody = {
            message: message,
            model: options.model || 'gpt-3.5-turbo',
            systemMessage: options.systemMessage,
            temperature: options.temperature || 0.7,
            maxTokens: options.maxTokens || 500
        };

        const response = await fetch(`${this.baseUrl}/api/streamingchat/stream`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        return {
            async *[Symbol.asyncIterator]() {
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        
                        if (done) break;
                        
                        const chunk = decoder.decode(value, { stream: true });
                        const lines = chunk.split('\n');
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    yield data;
                                    
                                    if (data.type === 'completion') {
                                        return;
                                    }
                                } catch (e) {
                                    console.warn('Failed to parse SSE data:', line);
                                }
                            } else if (line.startsWith('error: ')) {
                                throw new Error(line.slice(7));
                            } else if (line === 'event: stream-end') {
                                return;
                            }
                        }
                    }
                } finally {
                    reader.releaseLock();
                }
            }
        };
    }
}

// Usage example
const client = new StreamingChatClient('https://localhost:5001');

async function displayStreamingResponse(message) {
    const responseDiv = document.getElementById('response');
    responseDiv.innerHTML = '';
    
    try {
        const stream = await client.streamChat(message);
        
        for await (const chunk of stream) {
            if (chunk.type === 'content') {
                responseDiv.innerHTML += chunk.content;
            } else if (chunk.type === 'completion') {
                console.log('Stream completed:', chunk.finishReason);
            }
        }
    } catch (error) {
        responseDiv.innerHTML = `Error: ${error.message}`;
    }
}
```

--------------------------------

### Streaming Chat Responses to Console (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/streaming.md

This method provides a complete example of streaming chat responses to a console application. It creates a streaming request, executes it, and then iterates through the chunks, printing the content to the console as it arrives, followed by a newline.

```csharp
public async Task StreamChatToConsole()
{
    var stream = client.Chat.CreateRequest()
        .WithModel("anthropic/claude-3-haiku")
        .WithUserMessage("Explain quantum computing")
        .WithStreaming()
        .ExecuteStreamAsync();

    await foreach (var chunk in stream)
    {
        var content = chunk.Choices?.FirstOrDefault()?.Delta?.Content;
        if (!string.IsNullOrEmpty(content))
        {
            Console.Write(content);
        }
    }
    Console.WriteLine();
}
```

--------------------------------

### Disposing Resources - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/streaming-examples.md

This `Dispose` method, typically part of the `IDisposable` interface, is responsible for cleaning up unmanaged resources. It ensures that the `CancellationTokenSource` is cancelled and disposed of, preventing potential memory leaks and ensuring proper resource management when the component is no longer needed.

```C#
public void Dispose()
    {
        cancellationTokenSource?.Cancel();
        cancellationTokenSource?.Dispose();
    }
```

--------------------------------

### Integrating OAuth with ASP.NET Core Web Application (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/oauth.md

This example illustrates OAuth integration within an ASP.NET Core web application. It includes a `Login` endpoint to initiate the OAuth flow by redirecting to the authorization URL and a `Callback` endpoint to handle the OAuth redirect, exchange the code for tokens, and store the access token.

```C#
[HttpGet("login")]
public async Task<IActionResult> Login()
{
    var authUrl = await client.Auth.GetAuthorizationUrlAsync(
        redirectUri: "https://localhost:5001/auth/callback",
        scopes: new[] { "chat", "models" }
    );
    
    return Redirect(authUrl);
}

[HttpGet("auth/callback")]
public async Task<IActionResult> Callback(string code, string state)
{
    var tokens = await client.Auth.ExchangeCodeForTokensAsync(code);
    
    // Store tokens in session or database
    HttpContext.Session.SetString("access_token", tokens.AccessToken);
    
    return RedirectToAction("Index", "Home");
}
```

--------------------------------

### Handling OpenRouter Streaming Exceptions (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/streaming.md

This example demonstrates how to implement error handling for streaming operations using a `try-catch` block. It specifically catches `OpenRouterStreamingException` to manage and log errors that occur during the streaming process, allowing for specific error recovery.

```csharp
try
{
    await foreach (var chunk in streamResponse)
    {
        ProcessChunk(chunk);
    }
}
catch (OpenRouterStreamingException ex)
{
    Console.WriteLine($"Streaming error: {ex.Message}");
    // Handle streaming-specific errors
}
```

--------------------------------

### OpenRouter Configuration in appsettings.json (JSON)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Provides an example of how to structure OpenRouter API key and base URL settings within an appsettings.json file. This is a standard practice in ASP.NET Core applications for externalizing configuration, making it easy to manage settings across different environments.

```JSON
{
  "OpenRouter": {
    "ApiKey": "your_api_key_here",
    "ValidateApiKey": true,
    "BaseUrl": "https://openrouter.ai/api/v1"
  }
}
```

--------------------------------

### Managing HttpClient Lifecycle with AddOpenRouterWithHttpClient in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This example demonstrates the use of AddOpenRouterWithHttpClient() to leverage IHttpClientFactory for proper HttpClient lifecycle management. This approach ensures HttpClient instances are reused for performance, correctly disposed, handle DNS changes, and enable connection pooling, preventing common HttpClient pitfalls.

```csharp
// Proper HttpClient disposal and reuse
builder.Services.AddOpenRouterWithHttpClient(
    configure: options => /* configuration */,
    configureHttpClient: client => /* HttpClient setup */
);

// HttpClient will be:
// - Reused for performance
// - Properly disposed
// - DNS changes handled automatically
// - Connection pooling enabled
```

--------------------------------

### Performing OpenRouter Integration Tests in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This C# integration test example uses WebApplicationFactory to test an ASP.NET Core application with real OpenRouter services. It configures the test host to override OpenRouterOptions with a test API key, allowing for end-to-end testing of API interactions.

```C#
public class OpenRouterIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly WebApplicationFactory<Program> _factory;

    public OpenRouterIntegrationTests(WebApplicationFactory<Program> factory)
    {
        _factory = factory;
    }

    [Fact]
    public async Task ChatCompletion_Integration_Success()
    {
        // Arrange
        var client = _factory.WithWebHostBuilder(builder =>
        {
            builder.ConfigureServices(services =>
            {
                // Override with test API key
                services.Configure<OpenRouterOptions>(options =>
                {
                    options.ApiKey = Environment.GetEnvironmentVariable("TEST_OPENROUTER_API_KEY")!;
                });
            });
        }).CreateClient();

        // Act
        var response = await client.PostAsJsonAsync("/api/chat/complete", new
        {
            model = "gpt-3.5-turbo",
            message = "Hello, World!"
        });

        // Assert
        response.EnsureSuccessStatusCode();
        var content = await response.Content.ReadAsStringAsync();
        Assert.Contains("Hello", content);
    }
}
```

--------------------------------

### Configuring OpenRouter Client for Production in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

This C# snippet illustrates a robust production configuration for the OpenRouter client using dependency injection. It sets the API key from environment variables, enables API key validation, throws exceptions on API errors, and configures retry mechanisms with a specified number of attempts and delay. This setup ensures resilience and proper error handling in a production environment.

```C#
// Production configuration with comprehensive error handling
services.AddOpenRouter(options =>
{
    options.ApiKey = Environment.GetEnvironmentVariable("OPENROUTER_API_KEY")
        ?? throw new InvalidOperationException("OPENROUTER_API_KEY not configured");
    options.ValidateApiKey = true;
    options.ThrowOnApiErrors = true;
    options.EnableRetry = true;
    options.MaxRetryAttempts = 3;
    options.RetryDelay = TimeSpan.FromSeconds(1);
});
```

--------------------------------

### Cancelling Active Chat Stream - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/streaming-examples.md

This method allows for the cancellation of an ongoing streaming chat completion. It utilizes the `CancellationTokenSource` to signal cancellation to the `StreamAsync` operation, providing a small delay to allow the cancellation to propagate before the UI updates.

```C#
private async Task CancelStream()
    {
        cancellationTokenSource?.Cancel();
        await Task.Delay(100); // Give time for cancellation to propagate
    }
```

--------------------------------

### Defining a Function Tool with Schema in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This C# example demonstrates how to define a `Tool` using `Tool.CreateFunction`. It specifies the tool's name ('get_weather'), a description, and a JSON schema for its parameters, including `location` (string) and `units` (enum), with `location` being a required parameter. This allows the model to understand and correctly call the tool.

```csharp
var weatherTool = Tool.CreateFunction(
    "get_weather",
    "Get current weather for a location",
    new
    {
        type = "object",
        properties = new
        {
            location = new { type = "string", description = "City name" },
            units = new { type = "string", enum = new[] { "celsius", "fahrenheit" } }
        },
        required = new[] { "location" }
    }
);
```

--------------------------------

### Defining Keys Service Interface Methods - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet defines the interface methods for `IKeysService`, providing comprehensive CRUD operations for API key management. It includes methods for listing, creating, retrieving, updating, and deleting API keys, as well as getting details for the current key.

```csharp
Task<KeysResponse> ListKeysAsync(CancellationToken cancellationToken = default);
Task<CreateKeyResponse> CreateKeyAsync(CreateKeyRequest request, CancellationToken cancellationToken = default);
Task<ApiKey> GetKeyAsync(string keyId, CancellationToken cancellationToken = default);
Task<ApiKey> UpdateKeyAsync(string keyId, UpdateKeyRequest request, CancellationToken cancellationToken = default);
Task DeleteKeyAsync(string keyId, CancellationToken cancellationToken = default);
Task<CurrentKeyResponse> GetCurrentKeyAsync(CancellationToken cancellationToken = default);
```

--------------------------------

### Configuring Web Search Options in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/fluent-api.md

This example illustrates how to configure advanced options, such as web search, using an action delegate within the fluent API. It allows for nested configuration, setting specific parameters like the maximum number of results and the time range for the web search feature.

```csharp
var response = await client.Chat
    .WithModel("gpt-4")
    .WithMessages(messages)
    .WithWebSearch(options => {
        options.MaxResults = 10;
        options.TimeRange = TimeRange.LastMonth;
    })
    .ExecuteAsync();
```

--------------------------------

### Configuring Web Search with Specific Domains in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

This C# example demonstrates how to configure a web search using the WebSearchOptions to specify a maximum number of results, restrict searches to a list of allowed domains, filter by content type (articles), limit results to a specific time range (last month), and set a minimum domain authority. This allows for fine-grained control over the search scope for a given query.

```C#
var techNewsSearch = await client.Chat
    .WithMessages("Latest AI technology breakthroughs")
    .WithWebSearch(options =>
    {
        options.MaxResults = 12;
        options.AllowedDomains = new[]
        {
            "techcrunch.com",
            "wired.com",
            "arstechnica.com",
            "theverge.com",
            "ieee.org",
            "nature.com"
        };
        options.ContentType = ContentType.Articles;
        options.TimeRange = TimeRange.LastMonth;
        options.MinDomainAuthority = DomainAuthority.High;
    })
    .ExecuteAsync();
```

--------------------------------

### Sending Streaming Chat Messages - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/streaming-examples.md

This asynchronous method handles sending user messages to the OpenRouter API and processing the streaming response. It initializes state, creates a streaming chat completion request, and iterates through chunks, updating the UI incrementally. It includes error handling for cancellation and general exceptions, finally adding the exchange to conversation history.

```C#
private async Task SendMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(currentMessage) || isStreaming)
            return;

        var userMessage = currentMessage.Trim();
        currentMessage = string.Empty;
        streamingResponse = string.Empty;
        isStreaming = true;
        streamingStats = new StreamingStats { StartTime = DateTime.Now };
        cancellationTokenSource = new CancellationTokenSource();

        try
        {
            var streamingRequest = OpenRouterClient.Chat
                .CreateStreamingChatCompletion(selectedModel)
                .AddUserMessage(userMessage)
                .WithTemperature(0.7);

            await foreach (var chunk in streamingRequest.StreamAsync(cancellationTokenSource.Token))
            {
                if (chunk.Choices?.Any() == true)
                {
                    var deltaContent = chunk.Choices[0].Delta?.Content;
                    if (!string.IsNullOrEmpty(deltaContent))
                    {
                        streamingResponse += deltaContent;
                        streamingStats.ChunksReceived++;
                        
                        // Update UI every few characters for smooth animation
                        if (streamingStats.ChunksReceived % 3 == 0)
                        {
                            await InvokeAsync(StateHasChanged);
                            await Task.Delay(10); // Small delay for visual effect
                        }
                    }

                    if (chunk.Choices[0].FinishReason != null)
                    {
                        break;
                    }
                }
            }

            // Add to conversation history
            conversationHistory.Add(new ConversationExchange
            {
                UserMessage = userMessage,
                AiResponse = streamingResponse
            });
        }
        catch (OperationCanceledException)
        {
            streamingResponse += "\n\n[Response cancelled by user]";
        }
        catch (Exception ex)
        {
            streamingResponse = $"Error: {ex.Message}";
        }
        finally
        {
            isStreaming = false;
            cancellationTokenSource?.Dispose();
            cancellationTokenSource = null;
            await InvokeAsync(StateHasChanged);
        }
    }
```

--------------------------------

### Implementing Server-Sent Events for Streaming Chat in ASP.NET Core C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/examples/streaming-examples.md

This C# ASP.NET Core controller (`StreamingChatController`) demonstrates how to set up an API endpoint (`/api/StreamingChat/stream`) that streams chat completion responses using Server-Sent Events (SSE). It configures HTTP headers for SSE, constructs a streaming request using `IOpenRouterClient`, and asynchronously iterates over chunks, sending content and completion events. It also includes error handling and a helper method (`WriteSSEAsync`) for writing SSE data.

```C#
using Microsoft.AspNetCore.Mvc;
using OpenRouter.Core;
using System.Text.Json;

[ApiController]
[Route("api/[controller]")]
public class StreamingChatController : ControllerBase
{
    private readonly IOpenRouterClient _openRouterClient;
    private readonly ILogger<StreamingChatController> _logger;

    public StreamingChatController(
        IOpenRouterClient openRouterClient, 
        ILogger<StreamingChatController> logger)
    {
        _openRouterClient = openRouterClient;
        _logger = logger;
    }

    [HttpPost("stream")]
    public async Task StreamChatCompletion([FromBody] StreamChatRequest request)
    {
        Response.Headers.Add("Content-Type", "text/event-stream");
        Response.Headers.Add("Cache-Control", "no-cache");
        Response.Headers.Add("Connection", "keep-alive");
        Response.Headers.Add("Access-Control-Allow-Origin", "*");

        try
        {
            _logger.LogInformation("Starting streaming chat completion");

            var streamingRequest = _openRouterClient.Chat
                .CreateStreamingChatCompletion(request.Model ?? "gpt-3.5-turbo")
                .AddUserMessage(request.Message)
                .WithTemperature(request.Temperature ?? 0.7)
                .WithMaxTokens(request.MaxTokens ?? 500);

            if (!string.IsNullOrEmpty(request.SystemMessage))
            {
                streamingRequest = streamingRequest.AddSystemMessage(request.SystemMessage);
            }

            await foreach (var chunk in streamingRequest.StreamAsync())
            {
                if (HttpContext.RequestAborted.IsCancellationRequested)
                {
                    _logger.LogInformation("Client disconnected, stopping stream");
                    break;
                }

                if (chunk.Choices?.Any() == true)
                {
                    var choice = chunk.Choices[0];
                    var deltaContent = choice.Delta?.Content;

                    if (!string.IsNullOrEmpty(deltaContent))
                    {
                        var sseData = new
                        {
                            type = "content",
                            content = deltaContent,
                            timestamp = DateTimeOffset.UtcNow
                        };

                        await WriteSSEAsync("data", JsonSerializer.Serialize(sseData));
                    }

                    // Send completion event
                    if (choice.FinishReason != null)
                    {
                        var completionData = new
                        {
                            type = "completion",
                            finishReason = choice.FinishReason,
                            timestamp = DateTimeOffset.UtcNow
                        };

                        await WriteSSEAsync("data", JsonSerializer.Serialize(completionData));
                        break;
                    }
                }
            }

            await WriteSSEAsync("event", "stream-end");
            _logger.LogInformation("Streaming completed successfully");
        }
        catch (OpenRouterException ex)
        {
            _logger.LogError(ex, "OpenRouter API error during streaming");
            await WriteSSEAsync("error", JsonSerializer.Serialize(new { error = ex.Message, type = ex.ErrorType }));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during streaming");
            await WriteSSEAsync("error", JsonSerializer.Serialize(new { error = "Internal server error" }));
        }
    }

    private async Task WriteSSEAsync(string eventType, string data)
    {
        await Response.WriteAsync($"{eventType}: {data}\n\n");
        await Response.Body.FlushAsync();
    }
}

public class StreamChatRequest
{
    public required string Message { get; set; }
    public string? Model { get; set; }
    public string? SystemMessage { get; set; }
    public double? Temperature { get; set; }
    public int? MaxTokens { get; set; }
}
```

--------------------------------

### Configuring Tool Choice in OpenRouter Chat API (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

Demonstrates how to configure tool choice for the OpenRouter Chat API using `WithToolChoice()`. It shows examples for 'auto' mode (model decides), forcing a specific function call, and disabling tool calls ('none'). This controls how the model interacts with provided tools.

```csharp
// Auto mode - let the model decide
var response1 = await client.Chat
    .WithMessages(message)
    .WithTools(tools)
    .WithToolChoice("auto")
    .ExecuteAsync();

// Force specific tool usage
var response2 = await client.Chat
    .WithMessages(message)
    .WithTools(tools)
    .WithToolChoice(new { type = "function", function = new { name = "get_weather" } })
    .ExecuteAsync();

// Disable tool calling
var response3 = await client.Chat
    .WithMessages(message)
    .WithTools(tools)
    .WithToolChoice("none")
    .ExecuteAsync();
```

--------------------------------

### Defining Model Service Interface Methods - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet defines the core interface methods for `IModelsService`, enabling operations such as listing all available models, retrieving models with optional filtering, getting detailed information for a specific model, and listing API endpoints. These methods are asynchronous and support cancellation.

```csharp
Task<ModelResponse> ListModelsAsync(CancellationToken cancellationToken = default);
Task<ModelResponse> GetModelsAsync(ModelsRequest? request = null, CancellationToken cancellationToken = default);
Task<ModelDetailsResponse> GetModelAsync(string modelId, CancellationToken cancellationToken = default);
Task<string[]> ListEndpointsAsync(CancellationToken cancellationToken = default);
```

--------------------------------

### Configuring Logit Bias and Log Probabilities in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/fluent-api.md

This example illustrates the use of `WithLogitBias()` and `WithLogprobs()` methods for advanced token-level control. `WithLogitBias()` allows influencing token generation probabilities, while `WithLogprobs()` enables retrieving top log probabilities for generated tokens, useful for specialized NLP tasks and analysis.

```C#
var response = await client.Chat
    .WithModel("gpt-4")
    .WithMessages(messages)
    .WithLogitBias(new Dictionary<string, float> { ["yes"] = 10.0f, ["no"] = -10.0f })
    .WithLogprobs(5)
    .ExecuteAsync();
```

--------------------------------

### Handling OpenRouterTimeoutException (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This C# example demonstrates how to catch and handle an `OpenRouterTimeoutException`. It shows how to access the `Timeout` property to display the duration that was exceeded. This pattern is useful for implementing retry logic or adjusting timeout configurations based on the specific timeout duration.

```csharp
try
{
    var response = await client.Chat.CreateAsync(request);
}
catch (OpenRouterTimeoutException ex)
{
    Console.WriteLine($"Request timed out after {ex.Timeout}");
    // Consider retrying with longer timeout or different configuration
}
```

--------------------------------

### Demonstrating OpenRouter Service Integration Patterns (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This C# snippet illustrates coordinated usage of multiple OpenRouter client services, showcasing common integration patterns. It demonstrates listing models, creating a chat completion request with a selected model using a fluent API, and retrieving account credits, highlighting how different services can be used together. It requires an initialized `client` instance.

```C#
// Coordinated service usage
var models = await client.Models.ListModelsAsync();
var selectedModel = models.Data.First(m => m.Id.Contains("gpt-4"));

var response = await client.Chat
    .CreateRequest()
    .WithModel(selectedModel.Id)
    .WithUserMessage("Hello!")
    .ExecuteAsync();

var credits = await client.Credits.GetCreditsAsync();
Console.WriteLine($"Remaining credits: {credits.Credits}");
```

--------------------------------

### Validating OpenRouter Client Configuration (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This example demonstrates how to validate `OpenRouterOptions` after initialization. It sets an API key, maximum retry attempts, and a timeout. The `Validate()` method is then called to ensure all configuration values meet the client's requirements, such as a non-empty API key and positive timeout values, throwing an exception if any validation fails.

```csharp
var options = new OpenRouterOptions
{
    ApiKey = "your-api-key",
    MaxRetryAttempts = 5,
    Timeout = TimeSpan.FromSeconds(45)
};

options.Validate(); // Throws if invalid
```

--------------------------------

### Inspecting Chat Request Payload in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/fluent-api.md

This snippet demonstrates using the Build() method to obtain the chat request object without immediately executing it. This allows developers to inspect or modify the request payload, for example, by serializing it to JSON, before the request is sent to the API.

```csharp
var request = client.Chat
    .WithModel("gpt-4")
    .WithMessages(messages)
    .Build();

// Inspect or modify the request before sending
var jsonPayload = JsonSerializer.Serialize(request);
```

--------------------------------

### Generating AI Tools from .NET Methods in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

This C# example demonstrates how to automatically generate AI tool definitions from .NET methods using custom attributes (`ToolFunction` and `ToolParameter`). The `ToolGenerator` class reflects on types to find methods marked as tool functions, converting them into structured `Tool` objects with function names, descriptions, and parameter schemas.

```C#
public class WeatherService
{
    [ToolFunction("get_weather", "Get current weather for a location")]
    public async Task<WeatherResult> GetWeatherAsync(
        [ToolParameter("location", "City and state")] string location,
        [ToolParameter("unit", "Temperature unit")] string unit = "fahrenheit")
    {
        // Implementation
        return new WeatherResult();
    }
}

public class ToolGenerator
{
    public static Tool[] GenerateTools<T>()
    {
        var type = typeof(T);
        var methods = type.GetMethods()
            .Where(m => m.GetCustomAttribute<ToolFunctionAttribute>() != null);
            
        return methods.Select(GenerateToolFromMethod).ToArray();
    }
    
    private static Tool GenerateToolFromMethod(MethodInfo method)
    {
        var attr = method.GetCustomAttribute<ToolFunctionAttribute>();
        var parameters = GenerateParameterSchema(method);
        
        return new Tool
        {
            Function = new Function
            {
                Name = attr.Name,
                Description = attr.Description,
                Parameters = parameters
            }
        };
    }
}
```

--------------------------------

### Handling OpenRouterValidationException (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This C# example demonstrates how to catch and handle an `OpenRouterValidationException`. It shows how to access the exception message and iterate through the `ValidationErrors` dictionary to display specific field-level validation issues. This pattern is crucial for providing user-friendly error feedback when API requests fail validation.

```csharp
try
{
    var response = await client.Chat.CreateAsync(invalidRequest);
}
catch (OpenRouterValidationException ex)
{
    Console.WriteLine($"Validation failed: {ex.Message}");
    
    if (ex.ValidationErrors != null)
    {
        foreach (var error in ex.ValidationErrors)
        {
            Console.WriteLine($"Field '{error.Key}': {string.Join(", ", error.Value)}");
        }
    }
}
```

--------------------------------

### Implementing API Key Providers in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

Defines an 'IApiKeyProvider' interface and provides two concrete implementations: 'EnvironmentApiKeyProvider' for fetching keys from environment variables and 'DatabaseApiKeyProvider' for fetching from a database, demonstrating flexible API key management strategies.

```csharp
public interface IApiKeyProvider
{
    Task<string> GetApiKeyAsync();
    Task RefreshApiKeyAsync();
}

public class EnvironmentApiKeyProvider : IApiKeyProvider
{
    public Task<string> GetApiKeyAsync()
    {
        return Task.FromResult(Environment.GetEnvironmentVariable("OPENROUTER_API_KEY"));
    }
    
    public Task RefreshApiKeyAsync()
    {
        // Implement key refresh logic
        return Task.CompletedTask;
    }
}

public class DatabaseApiKeyProvider : IApiKeyProvider
{
    private readonly IUserContext userContext;
    private readonly IApiKeyRepository repository;
    
    public async Task<string> GetApiKeyAsync()
    {
        var userId = userContext.GetCurrentUserId();
        return await repository.GetApiKeyAsync(userId);
    }
}
```

--------------------------------

### Implementing Response Validation Framework in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/structured-outputs.md

This C# code defines a generic `ResponseValidator<T>` class for composing multiple validation rules using an `IValidator<T>` interface. It aggregates validation errors from all registered validators, returning a `ValidationResult`. An example `PersonInfoValidator` demonstrates specific validation rules for name, age, and email.

```C#
public class ResponseValidator<T>
{
    private readonly List<IValidator<T>> validators = new();
    
    public ResponseValidator<T> AddValidator(IValidator<T> validator)
    {
        validators.Add(validator);
        return this;
    }
    
    public ValidationResult Validate(T response)
    {
        var errors = new List<string>();
        
        foreach (var validator in validators)
        {
            var result = validator.Validate(response);
            if (!result.IsValid)
            {
                errors.AddRange(result.Errors);
            }
        }
        
        return new ValidationResult
        {
            IsValid = errors.Count == 0,
            Errors = errors
        };
    }
}

public class PersonInfoValidator : IValidator<PersonInfo>
{
    public ValidationResult Validate(PersonInfo person)
    {
        var errors = new List<string>();
        
        if (string.IsNullOrWhiteSpace(person.Name))
            errors.Add("Name is required");
            
        if (person.Age <= 0 || person.Age > 150)
            errors.Add("Age must be between 1 and 150");
            
        if (!string.IsNullOrEmpty(person.Email) && !IsValidEmail(person.Email))
            errors.Add("Invalid email format");
            
        return new ValidationResult { IsValid = errors.Count == 0, Errors = errors };
    }
}
```

--------------------------------

### Performing Concurrent Operations with OpenRouter Client (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This example demonstrates safe concurrent usage of the `OpenRouterClient` by initiating multiple chat requests in parallel. It creates 10 asynchronous tasks, each sending a unique message to the chat service, and then uses `Task.WhenAll` to await their completion. This pattern showcases the client's thread-safe design for concurrent operations, allowing efficient parallel processing of requests.

```csharp
// Safe concurrent usage
var tasks = Enumerable.Range(0, 10).Select(i => 
    client.Chat
        .CreateRequest()
        .WithModel("gpt-3.5-turbo")
        .WithUserMessage($"Message {i}")
        .ExecuteAsync());

var responses = await Task.WhenAll(tasks);
```

--------------------------------

### Extending OpenRouter Chat Builder with Custom C# Extensions

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/fluent-api.md

This snippet demonstrates how to extend the fluent API of the `IChatRequestBuilder` using C# extension methods. It provides examples of `WithConversationalTone()` and `WithCodeGeneration()` extensions, which encapsulate common configurations (like temperature, topP, and system messages) into reusable, domain-specific methods, enhancing code readability and reusability.

```C#
public static class ChatBuilderExtensions
{
    public static IChatRequestBuilder WithConversationalTone(this IChatRequestBuilder builder)
    {
        return builder
            .WithTemperature(0.8f)
            .WithTopP(0.9f)
            .WithSystemMessage("Respond in a friendly, conversational tone.");
    }
    
    public static IChatRequestBuilder WithCodeGeneration(this IChatRequestBuilder builder)
    {
        return builder
            .WithTemperature(0.2f)
            .WithMaxTokens(2000)
            .WithSystemMessage("Generate clean, well-documented code with explanations.");
    }
}
```

--------------------------------

### Convenience Constructor for OpenRouterClient (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This C# code defines a convenience constructor for the `OpenRouterClient` class. It simplifies initialization by accepting an API key directly, an optional action for further configuration of `OpenRouterOptions`, and an optional logger for diagnostics.

```C#
public OpenRouterClient(
    string apiKey, 
    Action<OpenRouterOptions>? configure = null, 
    ILogger<OpenRouterClient>? logger = null)
```

--------------------------------

### Defining C# Class for Automatic JSON Schema Generation

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/structured-outputs.md

This C# snippet illustrates how to define a ProductReview class and an ReviewCategory enum, incorporating data annotations like [Required], [Range], [MaxLength], and [JsonPropertyName]. These attributes guide the OpenRouter library in automatically generating a comprehensive JSON schema, ensuring validation rules and custom property names are applied to the structured output.

```C#
// C# Class
public class ProductReview
{
    [Required]
    public string ProductName { get; set; }
    
    [Range(1, 5)]
    public int Rating { get; set; }
    
    [MaxLength(1000)]
    public string ReviewText { get; set; }
    
    public bool IsRecommended { get; set; }
    
    [JsonPropertyName("review_date")]
    public DateTime ReviewDate { get; set; }
    
    public ReviewCategory[] Categories { get; set; }
}

public enum ReviewCategory
{
    Quality,
    Value,
    Service,
    Delivery
}
```

--------------------------------

### Implementing OpenRouter Options Pattern in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

This C# snippet shows how to integrate `OpenRouterOptions` with the .NET Options pattern, binding configuration from `appsettings.json` to the `OpenRouterOptions` class and then injecting `IOpenRouterClient` as a singleton using the configured options.

```csharp
services.Configure<OpenRouterOptions>(
    configuration.GetSection("OpenRouter"));

services.AddSingleton<IOpenRouterClient>(provider =>
{
    var options = provider.GetRequiredService<IOptions<OpenRouterOptions>>().Value;
    return new OpenRouterClient(options);
});
```

--------------------------------

### Creating Test Service Providers for OpenRouter in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This C# code defines a static class `TestServiceProvider` that provides methods to create `ServiceProvider` instances. It includes `CreateWithMockOpenRouter` for unit testing with a mocked `IOpenRouterClient` and `CreateWithRealOpenRouter` for integration tests using a real OpenRouter API key, both adding console logging. It requires `Microsoft.Extensions.DependencyInjection`, `Microsoft.Extensions.Logging`, and potentially `Moq` for mocking.

```csharp
public static class TestServiceProvider
{
    public static ServiceProvider CreateWithMockOpenRouter()
    {
        var services = new ServiceCollection();
        
        // Add logging
        services.AddLogging(builder => builder.AddConsole());
        
        // Add mock OpenRouter services
        var mockClient = new Mock<IOpenRouterClient>();
        services.AddSingleton(mockClient.Object);
        
        return services.BuildServiceProvider();
    }

    public static ServiceProvider CreateWithRealOpenRouter(string apiKey)
    {
        var services = new ServiceCollection();
        
        services.AddLogging(builder => builder.AddConsole());
        services.AddOpenRouter(apiKey);
        
        return services.BuildServiceProvider();
    }
}

// Usage in tests
var provider = TestServiceProvider.CreateWithMockOpenRouter();
var service = provider.GetRequiredService<IOpenRouterClient>();
```

--------------------------------

### Running Unit Tests for OpenRouter .NET

Source: https://github.com/xyoz-dev/openrouter/blob/master/README.md

This command executes unit tests for the OpenRouter .NET project. It uses `dotnet test` and filters tests by the 'Unit' category, ensuring only unit-level tests are run.

```bash
# Run unit tests
dotnet test OpenRouter.Tests --filter Category=Unit
```

--------------------------------

### Performing Basic Chat Completion with OpenRouter - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/README.md

This C# snippet demonstrates how to initialize the OpenRouter client with an API key and perform a simple chat completion request. It sends a user message to a specified model and prints the first choice's content.

```C#
using OpenRouter.Core;

// Initialize client
var client = new OpenRouterClient("your-api-key-here");

// Simple chat completion
var response = await client.Chat
    .CreateRequest()
    .WithModel("meta-llama/llama-3.1-8b-instruct:free")
    .AddUserMessage("Hello, how are you?")
    .SendAsync();

Console.WriteLine(response.GetFirstChoiceMessageContent());
```

--------------------------------

### Running Integration Tests for OpenRouter .NET

Source: https://github.com/xyoz-dev/openrouter/blob/master/README.md

This command runs integration tests for the OpenRouter .NET project. It first sets the `OPENROUTER_API_KEY` environment variable, which is required for integration tests, and then uses `dotnet test` to filter and execute tests categorized as 'Integration'.

```bash
# Run integration tests (requires API key)
export OPENROUTER_API_KEY="your-api-key-here"
dotnet test OpenRouter.Tests --filter Category=Integration
```

--------------------------------

### Creating Default UsageConfig in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This snippet provides a factory method for the `UsageConfig` class, allowing for easy creation of a default configuration. The `Default` method initializes the configuration with standard settings for usage tracking and cost reporting.

```csharp
static UsageConfig Default();
```

--------------------------------

### Cloning OpenRouter .NET Repository (Bash)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/index.md

This command clones the OpenRouter .NET library repository from GitHub to your local machine, providing the source code for direct project referencing.

```bash
git clone https://github.com/xyOz-dev/OpenRouter.git
```

--------------------------------

### Creating Default WebSearchOptions in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This snippet provides a factory method for the `WebSearchOptions` class, allowing for easy creation of a default configuration. The `Default` method initializes the configuration with standard settings for web search integration.

```csharp
static WebSearchOptions Default();
```

--------------------------------

### Binding OpenRouterOptions from Configuration (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This C# snippet demonstrates two ways to bind `OpenRouterOptions` from the application's configuration, typically `appsettings.json`. It shows how to bind an entire section and how to combine binding with programmatic overrides or additions, allowing for environment-specific adjustments.

```C#
// Bind entire configuration section
builder.Services.AddOpenRouter(options =>
    builder.Configuration.GetSection("OpenRouter").Bind(options));

// Or configure specific properties
builder.Services.AddOpenRouter(options =>
{
    builder.Configuration.GetSection("OpenRouter").Bind(options);
    
    // Override or add additional configuration
    options.EnableLogging = builder.Environment.IsDevelopment();
    options.LogLevel = builder.Environment.IsDevelopment() 
        ? LogLevel.Debug 
        : LogLevel.Warning;
});
```

--------------------------------

### Helper Methods for OpenRouter Tool Choice (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

Provides static helper methods within `ToolChoiceExtensions` to simplify the creation of tool choice configurations. It includes methods for 'auto', 'none', 'required', and a `Function` method to specify a tool by name, improving code readability and reusability.

```csharp
public static class ToolChoiceExtensions
{
    public static object Auto() => "auto";
    
    public static object None() => "none";
    
    public static object Required() => "required";
    
    public static object Function(string functionName)
    {
        return new
        {
            type = "function",
            function = new { name = functionName }
        };
    }
}

// Usage
var response = await client.Chat
    .WithMessages(message)
    .WithTools(tools)
    .WithToolChoice(ToolChoiceExtensions.Function("get_weather"))
    .ExecuteAsync();
```

--------------------------------

### Composing C# Tools into Workflows

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

This C# class demonstrates a strategy for composing multiple tools into a sequential workflow. It iterates through predefined workflow steps, executes each tool call, and maintains a `WorkflowContext` to pass information and accumulate results between steps. It relies on `workflowDefinitions` and an `IToolExecutor`.

```csharp
public class CompositeToolWorkflow
{
    public async Task<string> ExecuteWorkflow(string workflow, object parameters)
    {
        var steps = workflowDefinitions[workflow];
        var context = new WorkflowContext(parameters);
        
        foreach (var step in steps)
        {
            var toolCall = new ToolCall
            {
                Function = new Function
                {
                    Name = step.ToolName,
                    Arguments = JsonSerializer.Serialize(
                        step.BuildArguments(context))
                }
            };
            
            var result = await toolExecutor.ExecuteAsync(toolCall);
            context.AddResult(step.Name, result);
        }
        
        return context.GetFinalResult();
    }
}
```

--------------------------------

### Processing OAuth Callbacks and Token Exchange in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Illustrates a method for handling the OAuth callback, including state validation and exchanging the authorization code for tokens using the IOpenRouterClient. It highlights error handling for invalid state and the use of configuration for client details.

```csharp
public async Task<AuthResponse> HandleOAuthCallbackAsync(
    string code, 
    string state, 
    string storedState, 
    string codeVerifier)
{
    // Validate state
    if (state != storedState)
    {
        throw new SecurityException("Invalid OAuth state parameter");
    }

    // Exchange code for tokens
    var authResponse = await _client.Auth.ExchangeCodeForTokenAsync(
        code: code,
        clientId: _configuration["OAuth:ClientId"],
        redirectUri: _configuration["OAuth:RedirectUri"],
        codeVerifier: codeVerifier
    );

    return authResponse;
}
```

--------------------------------

### Initializing OpenRouterClient with Bearer Token (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Demonstrates how to set up authentication using a BearerTokenProvider with a static token. This is suitable for scenarios where a pre-obtained bearer token is used for authentication, providing a flexible token-based security mechanism.

```C#
var tokenProvider = new BearerTokenProvider(
    token: "your_bearer_token",
    validateToken: true);

var httpClient = new OpenRouterHttpClient(
    new HttpClient(),
    tokenProvider,
    options,
    logger);

var client = new OpenRouterClient(httpClient, options);
```

--------------------------------

### Accessing Individual OpenRouter Services (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This snippet illustrates how to access and use individual services provided by the `OpenRouterClient` independently. It shows creating a chat request, specifying a model and user message, and executing it asynchronously. Additionally, it demonstrates listing available models and retrieving user credits, highlighting the modular access pattern for different API functionalities.

```csharp
// Access specific services
var chatResponse = await client.Chat
    .CreateRequest()
    .WithModel("gpt-3.5-turbo")
    .WithUserMessage("Hello!")
    .ExecuteAsync();

var models = await client.Models.ListModelsAsync();
var credits = await client.Credits.GetCreditsAsync();
```

--------------------------------

### Configuring OpenRouterClient with Options (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Shows how to configure the OpenRouterClient using OpenRouterOptions to set the API key, enable API key format validation, and control whether exceptions are thrown on API errors. This approach provides more granular control over the client's behavior and security settings.

```C#
var options = new OpenRouterOptions
{
    ApiKey = "your_api_key_here",
    ValidateApiKey = true, // Validates key format before requests
    ThrowOnApiErrors = true // Throws exceptions on API errors
};

var client = new OpenRouterClient(
    CreateHttpClient(options), 
    options);
```

--------------------------------

### Secure API Key Retrieval (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Illustrates a secure way to retrieve an API key by first checking application configuration, then environment variables, and throwing an exception if the key is not found. This approach adheres to best practices by prioritizing externalized and secure storage over hardcoding.

```C#
var apiKey = configuration["OpenRouter:ApiKey"] 
    ?? Environment.GetEnvironmentVariable("OPENROUTER_API_KEY")
    ?? throw new InvalidOperationException("API key not configured");
```

--------------------------------

### Creating ToolChoice Instances with Static Factory Methods in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This snippet provides static factory methods for the `ToolChoice` class, simplifying the creation of tool choice configurations. Methods like `Auto()`, `None()`, and `Required()` offer predefined strategies, while `CreateFunction(string name)` allows forcing the use of a specific named function.

```csharp
static ToolChoice Auto();      // Let model decide
static ToolChoice None();      // Don't use tools
static ToolChoice Required();  // Must use a tool
static ToolChoice CreateFunction(string name);  // Force specific function
```

--------------------------------

### Creating Default ReasoningConfig in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This snippet provides a factory method for the `ReasoningConfig` class, allowing for easy creation of a default configuration. The `Default` method initializes the configuration with a specified `maxTokens` limit for reasoning output, defaulting to 1000 tokens.

```csharp
static ReasoningConfig Default(int maxTokens = 1000);
```

--------------------------------

### Basic HttpClient Configuration for OpenRouter Client in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

This C# snippet demonstrates basic `HttpClient` configuration for the `IOpenRouterClient`, setting the base address, adding a default user-agent header, and configuring a request timeout directly within the `AddHttpClient` method.

```csharp
services.AddHttpClient<IOpenRouterClient, OpenRouterClient>(client =>
{
    client.BaseAddress = new Uri("https://openrouter.ai/api/v1/");
    client.DefaultRequestHeaders.Add("User-Agent", "MyApp/1.0");
    client.Timeout = TimeSpan.FromMinutes(2);
});
```

--------------------------------

### Registering OpenRouterClient as Singleton in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This snippet shows how to explicitly register IOpenRouterClient as a Singleton. This is useful for console applications or services where a single instance of the client is desired throughout the application's lifetime, providing a custom OpenRouterOptions with a hardcoded API key for demonstration.

```csharp
// Register as Singleton for console applications
services.AddSingleton<IOpenRouterClient>(provider =>
{
    var options = new OpenRouterOptions { ApiKey = "your_api_key" };
    return new OpenRouterClient("your_api_key", opt => opt = options);
});
```

--------------------------------

### Static Methods for MessageContent Creation (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Provides static factory methods to simplify the creation of `MessageContent` instances for different content types. These methods allow easy construction of text, image, and document content objects.

```C#
static MessageContent CreateText(string text);
static MessageContent Image(string url, string? detail = null);
static MessageContent Document(string url, string? type = "pdf");
```

--------------------------------

### Performing Tool Calling with OpenRouter C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/README.md

This snippet demonstrates how to perform tool calling using the OpenRouter C# client. It creates a chat request, specifies a model, adds a user message, and defines a tool named 'get_weather' with a 'location' parameter, then sends the request asynchronously.

```csharp
var response = await client.Chat
    .CreateRequest()
    .WithModel("openai/gpt-4o")
    .AddUserMessage("What's the weather like?")
    .AddTool("get_weather", "Get current weather", new
    {
        type = "object",
        properties = new
        {
            location = new { type = "string", description = "City name" }
        }
    })
    .SendAsync();
```

--------------------------------

### Configuring OpenRouter Options with appsettings.json

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

This JSON snippet demonstrates how to configure the OpenRouter client options using an `appsettings.json` file. It includes settings for API key, base URL, timeouts, retry attempts, and logging, allowing for externalized and environment-specific configuration.

```json
{
  "OpenRouter": {
    "ApiKey": "your-api-key",
    "BaseUrl": "https://openrouter.ai/api/v1",
    "Timeout": "00:02:00",
    "MaxRetries": 3,
    "EnableLogging": true,
    "HttpTimeout": "00:01:30"
  }
}
```

--------------------------------

### Configuring Advanced OpenRouter Options - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/README.md

This C# snippet demonstrates how to configure various advanced options for the OpenRouter client during dependency injection. It sets the API key, base URL, user agent, request timeout, and maximum retries for API calls.

```C#
services.AddOpenRouter(options =>
{
    options.ApiKey = "your-api-key";
    options.BaseUrl = "https://openrouter.ai";
    options.UserAgent = "MyApp/1.0.0";
    options.Timeout = TimeSpan.FromSeconds(30);
    options.MaxRetries = 3;
});
```

--------------------------------

### Retrieving API Key from Environment Variable (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Shows how to retrieve the API key from an environment variable named OPENROUTER_API_KEY and then use it to initialize the OpenRouterClient. This is the recommended and most secure approach for production applications to manage API keys.

```C#
var apiKey = Environment.GetEnvironmentVariable("OPENROUTER_API_KEY")
    ?? throw new InvalidOperationException("OPENROUTER_API_KEY environment variable not set");

var client = new OpenRouterClient(apiKey);
```

--------------------------------

### Static Factory Methods for Message Creation (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Offers static helper methods for creating `Message` instances with different roles and content types. These methods simplify message construction, supporting text-only, multi-modal, and tool-related messages.

```C#
static Message System(string content);
static Message User(string content);
static Message User(MessageContent[] content);
static Message Assistant(string content);
static Message Assistant(string? content, ToolCall[] toolCalls);
static Message Tool(string content, string toolCallId);
```

--------------------------------

### IChatRequestBuilder Advanced Configuration Methods in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet details advanced configuration methods for `IChatRequestBuilder`. It includes `WithLogitBias` for influencing token generation, `WithLogprobs` for enabling log probability outputs, and `WithStop` for defining sequences that halt generation, offering granular control over the model's behavior.

```C#
IChatRequestBuilder WithLogitBias(Dictionary<string, int> logitBias);
IChatRequestBuilder WithLogprobs(bool enabled, int? topLogprobs = null);
IChatRequestBuilder WithStop(params string[] stopSequences);
```

--------------------------------

### Configuring Tools with WithTools() in OpenRouter C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

This C# snippet demonstrates how to configure multiple predefined `Tool` instances (e.g., `weatherTool`, `calculatorTool`, `databaseTool`) with the OpenRouter chat client using the `WithTools()` method. It shows a basic approach to attach a collection of tools to a chat request, enabling the AI model to utilize them based on the user's message.

```C#
var tools = new[]
{
    weatherTool,
    calculatorTool,
    databaseTool
};

var response = await client.Chat
    .WithModel("gpt-4")
    .WithMessages("What's the weather like in Paris and calculate 15% tip on $120?")
    .WithTools(tools)
    .ExecuteAsync();
```

--------------------------------

### Configuring OpenRouter with Dependency Injection - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/README.md

This C# snippet illustrates how to integrate the OpenRouter client into an ASP.NET Core application using dependency injection. It registers the OpenRouter services with an API key, allowing the client to be resolved from the service provider.

```C#
using Microsoft.Extensions.DependencyInjection;
using OpenRouter.Extensions;

services.AddOpenRouter(options =>
{
    options.ApiKey = "your-api-key-here";
});

var client = serviceProvider.GetRequiredService<IOpenRouterClient>();
```

--------------------------------

### Handling OAuth Redirect Callback (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/oauth.md

This method demonstrates how to process the OAuth redirect callback. It first validates the `state` parameter for security, then exchanges the received `authorizationCode` for access tokens using `ExchangeCodeForTokensAsync`, and finally returns the obtained access token.

```C#
public async Task<string> HandleOAuthCallback(string authorizationCode, string state)
{
    // Verify state parameter
    if (!IsValidState(state))
    {
        throw new InvalidOperationException("Invalid state parameter");
    }

    // Exchange code for tokens
    var tokens = await client.Auth.ExchangeCodeForTokensAsync(authorizationCode);
    return tokens.AccessToken;
}
```

--------------------------------

### Optimizing Search Performance in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

This C# class demonstrates strategies for optimizing search performance, including parallel execution across multiple indices and post-search filtering based on performance metrics like load time and content quality. It also includes a method for collecting detailed search operation metrics.

```csharp
public class SearchPerformanceOptimizer
{
    public async Task<SearchResult[]> OptimizedSearch(string query, WebSearchOptions options)
    {
        // Parallel search execution
        var tasks = new[]
        {
            SearchPrimaryIndex(query, options),
            SearchSecondaryIndex(query, options),
            SearchCachedResults(query)
        };
        
        var results = await Task.WhenAll(tasks);
        
        // Merge and deduplicate results
        var mergedResults = MergeSearchResults(results);
        
        // Apply performance-based filtering
        return FilterByPerformanceMetrics(mergedResults, options);
    }
    
    private SearchResult[] FilterByPerformanceMetrics(SearchResult[] results, WebSearchOptions options)
    {
        return results
            .Where(r => r.LoadTime < TimeSpan.FromSeconds(2))
            .Where(r => r.ContentQuality > 0.5f)
            .Take(options.MaxResults)
            .ToArray();
    }
    
    public SearchMetrics CollectMetrics(SearchOperation operation)
    {
        return new SearchMetrics
        {
            QueryTime = operation.Duration,
            ResultCount = operation.Results.Length,
            CacheHitRate = operation.CacheHits / (float)operation.TotalRequests,
            AverageRelevance = operation.Results.Average(r => r.RelevanceScore),
            SourceDiversity = operation.Results.Select(r => r.Domain).Distinct().Count()
        };
    }
}
```

--------------------------------

### Creating an OAuth Authorization Request (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/oauth.md

This code initializes an `AuthRequest` object with essential parameters like client ID, redirect URI, desired scopes, and a unique state parameter. It then uses this request object to generate the full authorization URL via the `GetAuthorizationUrlAsync` method.

```C#
var authRequest = new AuthRequest
{
    ClientId = "your-client-id",
    RedirectUri = "https://your-app.com/callback",
    Scope = "chat models credits",
    State = Guid.NewGuid().ToString()
};

var authorizationUrl = await client.Auth.GetAuthorizationUrlAsync(authRequest);
```

--------------------------------

### Optimizing Search Queries with QueryOptimizer in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

This C# class provides strategies for enhancing and refining search queries. It includes methods to add domain-specific keywords, temporal modifiers, and specificity filters, remove ambiguous terms, generate query variations (e.g., synonyms, simplified, contextual), and refine queries based on initial search results to improve search effectiveness.

```csharp
public class QueryOptimizer
{
    public string OptimizeQuery(string originalQuery, SearchContext context)
    {
        var optimizedQuery = originalQuery;
        
        // Add domain-specific keywords
        optimizedQuery = AddDomainKeywords(optimizedQuery, context.Domain);
        
        // Include temporal modifiers
        if (context.RequiresRecent)
            optimizedQuery += " 2024";
            
        // Add specificity filters
        optimizedQuery = AddSpecificityFilters(optimizedQuery, context.Specificity);
        
        // Remove ambiguous terms
        optimizedQuery = RemoveAmbiguousTerms(optimizedQuery);
        
        return optimizedQuery;
    }
    
    public string[] GenerateQueryVariations(string baseQuery)
    {
        return new[]
        {
            baseQuery,
            AddSynonyms(baseQuery),
            SimplifyQuery(baseQuery),
            AddContextualTerms(baseQuery),
            CreateNaturalLanguageQuery(baseQuery)
        };
    }
    
    public async Task<string> RefineBasedOnResults(string originalQuery, SearchResult[] results)
    {
        if (results.Length == 0)
            return ExpandQuery(originalQuery);
            
        if (results.All(r => r.RelevanceScore < 0.3f))
            return RephaseQuery(originalQuery);
            
        return originalQuery; // Query is working well
    }
}
```

--------------------------------

### Adding OpenRouter .NET Project Reference (XML)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/index.md

This XML snippet demonstrates how to add a direct project reference to the OpenRouter .NET library in your .csproj file, integrating it into your Visual Studio solution.

```xml
<ProjectReference Include="path/to/OpenRouter/OpenRouter.csproj" />
```

--------------------------------

### Setting OPENROUTER_API_KEY Environment Variable (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Illustrates how to programmatically set an environment variable for the API key. This is a common practice for local development or CI/CD pipelines to avoid hardcoding sensitive information directly into the source code.

```C#
Environment.SetEnvironmentVariable("OPENROUTER_API_KEY", "your_api_key_here");
```

--------------------------------

### Enabling Basic Web Search in OpenRouter .NET

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

This snippet demonstrates how to activate web search with default settings using the `WithWebSearch()` method in the OpenRouter .NET library. It automatically generates queries from user input, retrieves a standard number of results, and applies default relevance scoring and basic source filtering.

```C#
var response = await client.Chat
    .WithModel("gpt-4")
    .WithMessages("What are the latest developments in renewable energy technology?")
    .WithWebSearch()
    .ExecuteAsync();
```

--------------------------------

### Listing and Displaying API Keys (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/api-keys.md

This snippet demonstrates how to retrieve a list of all API keys using GetKeysAsync and then iterate through the KeysResponse.Data collection to display details such as key ID, name, creation timestamp, and associated permissions.

```csharp
var keysResponse = await client.Keys.GetKeysAsync();
foreach (var key in keysResponse.Data)
{
    Console.WriteLine($"Key: {key.Id} - {key.Name}");
    Console.WriteLine($"Created: {key.CreatedAt}");
    Console.WriteLine($"Permissions: {string.Join(", ", key.Permissions)}");
}
```

--------------------------------

### Setting Temperature for Highly Creative Output in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet illustrates setting the Temperature parameter to 1.0. A temperature of 1.0 encourages the model to generate highly creative and diverse responses, introducing more randomness.

```C#
builder.WithTemperature(1.0); // Highly creative
```

--------------------------------

### Dynamically Configuring Web Search Options in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

This C# class provides a method to dynamically configure WebSearchOptions based on a given search context. It illustrates how to adjust parameters such as allowed domains, max results, time range, content type, and source credibility verification, depending on the topic of the search (e.g., Finance, Medical, News). This enables adaptive search behavior for different user needs.

```C#
public class ContextualSearchConfigurator
{
    public WebSearchOptions ConfigureSearch(string query, SearchContext context)
    {
        var options = new WebSearchOptions();
        
        if (context.Topic == SearchTopic.Finance)
        {
            options.AllowedDomains = new[] { "sec.gov", "bloomberg.com", "reuters.com" };
            options.MaxResults = 10;
            options.TimeRange = TimeRange.LastMonth;
        }
        else if (context.Topic == SearchTopic.Medical)
        {
            options.AllowedDomains = new[] { "pubmed.ncbi.nlm.nih.gov", "nejm.org", "bmj.com" };
            options.ContentType = ContentType.Academic;
            options.VerifySourceCredibility = true;
        }
        else if (context.Topic == SearchTopic.News)
        {
            options.ContentType = ContentType.News;
            options.TimeRange = TimeRange.LastDay;
            options.MaxResults = 8;
        }
        
        return options;
    }
}
```

--------------------------------

### Accessing Client Configuration in IOpenRouterClient (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This C# code snippet defines a read-only property `Options` within the `IOpenRouterClient` interface. It provides access to the client's `OpenRouterOptions` configuration settings, allowing inspection of current client behavior and parameters.

```C#
OpenRouterOptions Options { get; }
```

--------------------------------

### Configuring OpenRouter for Different Environments in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

This snippet demonstrates how to configure OpenRouter client options based on the application's environment (Development vs. Production). It sets different logging levels, enables/disables logging, and specifies base URLs accordingly, using `IServiceCollection` and `IConfiguration`.

```C#
public class EnvironmentSpecificOptions
{
    public string Environment { get; set; }
    public bool EnableDetailedLogging { get; set; }
    public bool EnableMetrics { get; set; }
    public string LogLevel { get; set; }
    public Dictionary<string, object> EnvironmentSettings { get; set; }
}

public void ConfigureOpenRouter(IServiceCollection services, IConfiguration configuration)
{
    var environment = configuration["Environment"] ?? "Production";
    
    if (environment == "Development")
    {
        services.Configure<OpenRouterOptions>(options =>
        {
            options.EnableLogging = true;
            options.LogLevel = LogLevel.Debug;
            options.BaseUrl = "https://openrouter.ai/api/v1";
        });
    }
    else
    {
        services.Configure<OpenRouterOptions>(options =>
        {
            options.EnableLogging = false;
            options.LogLevel = LogLevel.Warning;
            options.BaseUrl = configuration["OpenRouter:ProductionUrl"];
        });
    }
}
```

--------------------------------

### Factory Method for Tool Creation (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Provides a static factory method to simplify the creation of `Tool` instances, specifically for function tools. It allows defining the function's `name`, `description`, and optional `parameters` (as a JSON Schema object).

```C#
static Tool CreateFunction(string name, string description, object? parameters = null);
```

--------------------------------

### Chaining Fluent Chat Request Methods in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet demonstrates a complete fluent chain for building and executing a chat request. It configures the model, system message, user message, and various model parameters like temperature and max tokens before executing the request asynchronously.

```C#
var response = await client.Chat.CreateRequest()
    .WithModel("anthropic/claude-3-haiku")
    .WithSystemMessage("You are a coding assistant")
    .WithUserMessage("Write a hello world in C#")
    .WithTemperature(0.7)
    .WithMaxTokens(150)
    .ExecuteAsync();
```

--------------------------------

### Primary Constructor for OpenRouterClient (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This C# code defines the primary constructor for the `OpenRouterClient` class. It initializes the client with an HTTP client provider for API communication, configuration options, and an optional logger for diagnostics and debugging purposes.

```C#
public OpenRouterClient(
    IHttpClientProvider httpClient,
    OpenRouterOptions options,
    ILogger<OpenRouterClient>? logger = null)
```

--------------------------------

### Creating ChatCompletionRequest Manually in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet demonstrates how to manually instantiate a ChatCompletionRequest object. It sets the target model and initializes a basic user message, serving as the foundation for direct API calls.

```C#
var request = new ChatCompletionRequest
{
    Model = "anthropic/claude-3-haiku",
    Messages = new[]
    {
        new Message { Role = "user", Content = "Hello, world!" }
    }
};
```

--------------------------------

### Setting Frequency Penalty in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet demonstrates setting the WithFrequencyPenalty() parameter. A positive frequency penalty reduces the likelihood of the model repeating tokens that have already appeared in the response, promoting diversity.

```C#
builder.WithFrequencyPenalty(0.5);
```

--------------------------------

### Configuring OpenRouter for Different Environments in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This snippet demonstrates how to apply environment-specific configurations to the OpenRouter client using ASP.NET Core's IWebHostEnvironment. It shows how to enable/disable logging, set log levels, control retry mechanisms, and validate API keys based on whether the application is running in Development or Production.

```csharp
builder.Services.AddOpenRouter(options =>
{
    // Base configuration
    builder.Configuration.GetSection("OpenRouter").Bind(options);
    
    if (builder.Environment.IsDevelopment())
    {
        options.EnableLogging = true;
        options.LogLevel = LogLevel.Debug;
        options.EnableRetry = false; // Disable retry for faster debugging
        options.ValidateApiKey = true;
    }
    else if (builder.Environment.IsProduction())
    {
        options.EnableLogging = true;
        options.LogLevel = LogLevel.Warning;
        options.EnableRetry = true;
        options.MaxRetryAttempts = 5;
        options.ValidateApiKey = false; // Skip validation for performance
    }
});
```

--------------------------------

### Managing OpenRouter API Keys in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This C# snippet demonstrates how to perform common CRUD operations on OpenRouter API keys using the client. It covers listing existing keys, creating a new key with specified permissions, and updating an existing key's permissions. It requires an initialized `client` instance and the `CreateKeyRequest` and `UpdateKeyRequest` models.

```C#
// List all API keys
var keys = await client.Keys.ListKeysAsync();

// Create a new API key
var createRequest = new CreateKeyRequest
{
    Name = "Development Key",
    Permissions = new[] { "chat.completions", "models.list" }
};
var newKey = await client.Keys.CreateKeyAsync(createRequest);

// Update key permissions
var updateRequest = new UpdateKeyRequest
{
    Permissions = new[] { "chat.completions", "models.list", "credits.read" }
};
var updatedKey = await client.Keys.UpdateKeyAsync(newKey.Id, updateRequest);
```

--------------------------------

### Defining Credits Service Interface Methods - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet defines the interface methods for `ICreditsService`, which manages credit balance and payment operations. It includes methods for retrieving current credit balance, initiating Coinbase payments, and fetching detailed usage statistics.

```csharp
Task<CreditsResponse> GetCreditsAsync(CancellationToken cancellationToken = default);
Task<CoinbasePaymentResponse> CreateCoinbasePaymentAsync(CoinbasePaymentRequest request, CancellationToken cancellationToken = default);
Task<UsageResponse> GetUsageAsync(CancellationToken cancellationToken = default);
```

--------------------------------

### IChatRequestBuilder Core Configuration Methods in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet outlines the core configuration methods of the `IChatRequestBuilder` interface. These methods allow users to specify the AI model, define various types of messages (system, user, assistant), and manage message content for chat completion requests.

```C#
IChatRequestBuilder WithModel(string modelId);
IChatRequestBuilder WithMessages(params Message[] messages);
IChatRequestBuilder WithSystemMessage(string content);
IChatRequestBuilder WithUserMessage(string content);
IChatRequestBuilder WithUserMessage(MessageContent[] content);
IChatRequestBuilder WithAssistantMessage(string content);
```

--------------------------------

### Setting Up Structured Logging for OpenRouter in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

This snippet demonstrates how to configure structured logging using Serilog for the OpenRouter client. It sets up console and file logging with daily rolling intervals and filters logs to include only messages from the "OpenRouter" source. It also defines options for controlling logging behavior like request/response logging and sensitive field masking.

```C#
services.AddLogging(builder =>
{
    builder.AddSerilog(new LoggerConfiguration()
        .WriteTo.Console()
        .WriteTo.File("logs/openrouter-.txt", rollingInterval: RollingInterval.Day)
        .Filter.ByIncludingOnly(Matching.FromSource("OpenRouter"))
        .CreateLogger());
});

public class OpenRouterLoggingOptions
{
    public bool LogRequests { get; set; } = false;
    public bool LogResponses { get; set; } = false;
    public bool LogMetrics { get; set; } = true;
    public string[] SensitiveFields { get; set; } = { "api_key", "authorization" };
}
```

--------------------------------

### Framework for Executing OpenRouter Tool Calls (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

Defines a `ToolExecutor` class that manages and executes registered tool functions. It uses a dictionary to map tool names to their respective asynchronous execution methods, providing a robust and extensible way to handle various tool calls and their arguments, including error handling.

```csharp
public class ToolExecutor
{
    private readonly Dictionary<string, Func<string, Task<string>>> toolRegistry;
    
    public ToolExecutor()
    {
        toolRegistry = new Dictionary<string, Func<string, Task<string>>>
        {
            ["get_weather"] = ExecuteWeatherTool,
            ["calculate"] = ExecuteCalculatorTool,
            ["query_database"] = ExecuteDatabaseTool
        };
    }
    
    public async Task<string> ExecuteToolCall(ToolCall toolCall)
    {
        try
        {
            if (toolRegistry.TryGetValue(toolCall.Function.Name, out var executor))
            {
                return await executor(toolCall.Function.Arguments);
            }
            throw new InvalidOperationException($"Tool '{toolCall.Function.Name}' not found");
        }
        catch (Exception ex)
        {
            return JsonSerializer.Serialize(new { error = ex.Message });
        }
    }
    
    private async Task<string> ExecuteWeatherTool(string argumentsJson)
    {
        var args = JsonSerializer.Deserialize<WeatherArgs>(argumentsJson);
        var weather = await weatherService.GetWeatherAsync(args.Location, args.Unit);
        return JsonSerializer.Serialize(weather);
    }
}
```

--------------------------------

### Setting Top-k Sampling in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet shows how to set the TopK parameter. This parameter limits the model's token selection to the top k most probable tokens at each step, influencing the diversity of the output.

```C#
builder.WithTopK(40);
```

--------------------------------

### Implementing Fallback Model Selection in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/error-handling.md

This C# method `GetChatCompletionWithFallback` demonstrates a graceful degradation strategy by attempting chat completions with a list of models. If a model is unavailable or rate-limited, it logs a warning and attempts the next model in the list.

```csharp
public async Task<ChatCompletionResponse> GetChatCompletionWithFallback(string message)
{
    var models = new[] { "gpt-4", "gpt-3.5-turbo", "claude-3-sonnet" };
    
    foreach (var model in models)
    {
        try
        {
            return await client.Chat
                .WithModel(model)
                .WithMessages(message)
                .ExecuteAsync();
        }
        catch (OpenRouterProviderException ex) when (ex.IsProviderUnavailable)
        {
            logger.LogWarning(ex, "Model {Model} unavailable, trying fallback", model);
            continue;
        }
        catch (OpenRouterRateLimitException ex) when (ex.IsModelSpecific)
        {
            logger.LogWarning(ex, "Model {Model} rate limited, trying fallback", model);
            continue;
        }
    }
    
    throw new OpenRouterException("All fallback models failed");
}
```

--------------------------------

### Defining a Basic Weather Tool Function in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

This C# code demonstrates how to define a basic `Tool` for fetching weather information. It specifies the function name 'get_weather', a description, and parameters for 'location' (required string) and 'unit' (enum 'celsius' or 'fahrenheit'), adhering to a JSON schema-like structure for parameter validation.

```C#
var weatherTool = new Tool
{
    Function = new Function
    {
        Name = "get_weather",
        Description = "Get current weather information for a location",
        Parameters = new
        {
            type = "object",
            properties = new
            {
                location = new
                {
                    type = "string",
                    description = "The city and state, e.g. San Francisco, CA"
                },
                unit = new
                {
                    type = "string",
                    @enum = new[] { "celsius", "fahrenheit" },
                    description = "Temperature unit"
                }
            },
            required = new[] { "location" }
        }
    }
};
```

--------------------------------

### IChatRequestBuilder Streaming and Processing Methods in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet presents methods for controlling streaming behavior and reasoning token configuration in `IChatRequestBuilder`. It enables real-time chunk streaming and fine-grained control over the reasoning process of the AI model.

```C#
IChatRequestBuilder WithStreaming(bool enabled = true);
IChatRequestBuilder WithReasoningTokens(Action<ReasoningConfig> configure);
```

--------------------------------

### Setting Top-p (Nucleus Sampling) in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet demonstrates setting the TopP parameter, which is used in nucleus sampling. A value of 0.9 means the model considers tokens whose cumulative probability mass is within the top 90%.

```C#
builder.WithTopP(0.9);
```

--------------------------------

### Creating ResponseFormat Instances with Static Factory Methods in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This snippet provides static factory methods for the `ResponseFormat` class, simplifying the configuration of response formats. Methods like `Text()` and `Json()` offer common formats, while `JsonSchema(object schema)` allows specifying a custom JSON schema for structured outputs.

```csharp
static ResponseFormat Text();
static ResponseFormat Json();
static ResponseFormat JsonSchema(object schema);
```

--------------------------------

### Exchanging Authorization Code for Tokens (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/oauth.md

This function illustrates the process of exchanging an authorization code for tokens. It constructs a `TokenExchangeRequest` with the authorization code, a stored code verifier (for PKCE), and the original redirect URI, then calls `ExchangeTokenAsync` to complete the exchange.

```C#
public async Task<AuthResponse> ExchangeAuthorizationCode(string code)
{
    var tokenRequest = new TokenExchangeRequest
    {
        Code = code,
        CodeVerifier = storedCodeVerifier,
        RedirectUri = originalRedirectUri
    };

    return await client.Auth.ExchangeTokenAsync(tokenRequest);
}
```

--------------------------------

### Implementing Automatic Token Refresh for API Keys in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

Shows a 'RefreshableApiKeyProvider' class that implements 'IApiKeyProvider' with logic for caching API keys and automatically refreshing them when expired or not present, using a semaphore for thread-safe refresh operations to prevent race conditions.

```csharp
public class RefreshableApiKeyProvider : IApiKeyProvider
{
    private string cachedKey;
    private DateTime keyExpiry;
    private readonly SemaphoreSlim refreshSemaphore = new(1, 1);
    
    public async Task<string> GetApiKeyAsync()
    {
        if (string.IsNullOrEmpty(cachedKey) || DateTime.UtcNow >= keyExpiry)
        {
            await refreshSemaphore.WaitAsync();
            try
            {
                if (string.IsNullOrEmpty(cachedKey) || DateTime.UtcNow >= keyExpiry)
                {
                    await RefreshApiKeyAsync();
                }
            }
            finally
            {
                refreshSemaphore.Release();
            }
        }
        
        return cachedKey;
    }
}
```

--------------------------------

### Constructing OpenRouterConfigurationException (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This C# constructor initializes an `OpenRouterConfigurationException` with a message and an optional `configurationKey`. This exception is thrown when issues related to the client's configuration are detected, such as missing or invalid settings.

```csharp
public OpenRouterConfigurationException(string message, string? configurationKey = null);
```

--------------------------------

### OpenRouterOptions Configuration in appsettings.json (JSON)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This JSON snippet illustrates the structure for configuring `OpenRouterOptions` within an `appsettings.json` file. It defines various properties like API key, base URL, timeouts, retry settings, logging, and custom headers, which can then be bound to the `OpenRouterOptions` class.

```JSON
{
  "OpenRouter": {
    "ApiKey": "your_api_key_here",
    "BaseUrl": "https://openrouter.ai/api/v1",
    "Timeout": "00:00:30",
    "RequestTimeout": "00:02:00",
    "MaxRetryAttempts": 3,
    "RetryDelay": "00:00:01",
    "EnableRetry": true,
    "EnableLogging": true,
    "LogLevel": "Information",
    "ValidateApiKey": true,
    "ThrowOnApiErrors": true,
    "EnableStreamingOptimizations": true,
    "StreamingBufferSize": 8192,
    "DefaultHeaders": {
      "X-Custom-Header": "CustomValue"
    },
    "HttpReferer": "https://myapp.com",
    "XTitle": "My Application"
  }
}
```

--------------------------------

### Fluent Chat Request Builder Overview in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet illustrates the fluent builder pattern provided by IChatRequestBuilder. It demonstrates chaining methods like WithModel and WithUserMessage to construct a request, followed by ExecuteAsync to send it and retrieve the response.

```C#
var response = await client.Chat.CreateRequest()
    .WithModel("anthropic/claude-3-haiku")
    .WithUserMessage("Hello, world!")
    .ExecuteAsync();
```

--------------------------------

### Creating Chat Completion Request with OpenRouter API (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This snippet demonstrates how to construct a `ChatCompletionRequest` in C# for the OpenRouter API. It includes configuring the model, defining system and user messages, adding function calling tools, setting tool choice, enabling web search, and specifying provider preferences with pricing limits and fallback options. This request is used to send a query to the chat completion endpoint.

```csharp
var request = new ChatCompletionRequest
{
    Model = "gpt-4",
    Messages = new[]
    {
        Message.System("You are a helpful assistant with web search."),
        Message.User("What's the latest news about quantum computing?")
    },
    Tools = new[]
    {
        Tool.CreateFunction("web_search", "Search the web for information", 
            new { type = "object", properties = new { query = new { type = "string" } } })
    },
    ToolChoice = ToolChoice.Auto(),
    WebSearch = WebSearchOptions.Default(),
    Usage = UsageConfig.Default(),
    Provider = new ProviderPreferences
    {
        Order = new[] { "openai", "anthropic" },
        AllowFallbacks = true,
        MaxPrice = new PricingLimits { PerToken = 0.01 }
    }
};
```

--------------------------------

### Conditional Proxy Configuration Service in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

This C# class demonstrates a service for conditionally configuring an `HttpClientHandler` with proxy settings. It checks for a proxy URL in the configuration and applies it, including credentials, only if present, allowing for flexible environment-based proxy management.

```csharp
public class ProxyConfigurationService
{
    public HttpClientHandler CreateHandler(IConfiguration configuration)
    {
        var handler = new HttpClientHandler();
        
        var proxyUrl = configuration["Proxy:Url"];
        if (!string.IsNullOrEmpty(proxyUrl))
        {
            handler.UseProxy = true;
            handler.Proxy = new WebProxy(proxyUrl)
            {
                Credentials = GetProxyCredentials(configuration)
            };
        }
        
        return handler;
    }
}
```

--------------------------------

### Binding appsettings.json to OpenRouter Options (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Demonstrates how to integrate appsettings.json configuration into an ASP.NET Core application's service collection. This snippet shows how to bind the "OpenRouter" section of the configuration to the client options using the AddOpenRouter extension method.

```C#
// In Program.cs
builder.Services.AddOpenRouter(options =>
    builder.Configuration.GetSection("OpenRouter").Bind(options));
```

--------------------------------

### Setting Temperature for Deterministic Output in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet demonstrates setting the Temperature parameter to 0.0. A temperature of 0.0 makes the model's output highly deterministic, meaning it will produce the most probable response with minimal randomness.

```C#
builder.WithTemperature(0.0); // Deterministic
```

--------------------------------

### Defining PricingLimits Properties in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This snippet defines the properties of the `PricingLimits` class, which allows setting maximum price thresholds for API usage. It includes optional limits for cost `PerToken`, `PerRequest`, and `PerDay`, enabling users to control spending.

```csharp
double? PerToken { get; set; }
double? PerRequest { get; set; }
double? PerDay { get; set;}
```

--------------------------------

### Direct API Interaction Methods in IOpenRouterClient (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This C# code defines generic methods within `IOpenRouterClient` for direct interaction with OpenRouter API endpoints. `SendAsync<T>` sends a request and deserializes the response, while `StreamAsync<T>` streams responses from endpoints supporting streaming, offering advanced API access.

```C#
Task<T> SendAsync<T>(string endpoint, object? request = null, CancellationToken cancellationToken = default);
IAsyncEnumerable<T> StreamAsync<T>(string endpoint, object? request = null, CancellationToken cancellationToken = default);
```

--------------------------------

### Implementing Performance Metrics for OpenRouter in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

This code defines a class for collecting performance metrics for the OpenRouter client using `System.Diagnostics.Metrics`. It initializes counters for requests, errors, and a histogram for request durations, allowing for detailed monitoring of the client's operational performance.

```C#
public class OpenRouterMetrics
{
    private readonly Counter<long> requestCounter;
    private readonly Histogram<double> requestDuration;
    private readonly Counter<long> errorCounter;
    
    public OpenRouterMetrics(IMeterFactory meterFactory)
    {
        var meter = meterFactory.Create("OpenRouter");
        requestCounter = meter.CreateCounter<long>("openrouter.requests", "request");
        requestDuration = meter.CreateHistogram<double>("openrouter.request_duration", "ms");
        errorCounter = meter.CreateCounter<long>("openrouter.errors", "error");
    }
}
```

--------------------------------

### Implementing Robust Error Handling for C# Tool Execution

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

This C# class demonstrates a robust error handling pattern for tool execution. It uses a try-catch block to gracefully manage `ArgumentException`, `TimeoutException`, and general `Exception` types, logging errors and returning serialized error messages to the caller. It requires an `ILogger` for logging and `JsonSerializer` for result serialization.

```csharp
public class SafeToolExecutor
{
    private readonly ILogger<SafeToolExecutor> logger;
    
    public async Task<string> ExecuteWithErrorHandling(ToolCall toolCall)
    {
        try
        {
            logger.LogInformation("Executing tool: {ToolName}", toolCall.Function.Name);
            
            var result = await ExecuteTool(toolCall);
            
            logger.LogInformation("Tool executed successfully: {ToolName}", toolCall.Function.Name);
            return result;
        }
        catch (ArgumentException ex)
        {
            logger.LogWarning(ex, "Invalid arguments for tool: {ToolName}", toolCall.Function.Name);
            return JsonSerializer.Serialize(new 
            {
                error = "Invalid arguments", 
                details = ex.Message,
                tool = toolCall.Function.Name
            });
        }
        catch (TimeoutException ex)
        {
            logger.LogError(ex, "Tool execution timeout: {ToolName}", toolCall.Function.Name);
            return JsonSerializer.Serialize(new 
            {
                error = "Execution timeout", 
                tool = toolCall.Function.Name 
            });
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Tool execution failed: {ToolName}", toolCall.Function.Name);
            return JsonSerializer.Serialize(new 
            {
                error = "Execution failed", 
                message = ex.Message,
                tool = toolCall.Function.Name
            });
        }
    }
}
```

--------------------------------

### IChatRequestBuilder Performance Optimization Methods in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet outlines methods within `IChatRequestBuilder` for optimizing performance. It includes `WithPromptCaching` to enable or disable prompt caching and `WithMessageTransforms` to apply transformations to messages, aiming to improve efficiency and response times.

```C#
IChatRequestBuilder WithPromptCaching(bool enabled = true);
IChatRequestBuilder WithMessageTransforms(params string[] transforms);
```

--------------------------------

### Configuring Streaming Response Buffering in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

Defines a 'StreamingConfiguration' class to manage parameters for streaming responses, including 'BufferSize', 'MaxBufferedChunks', 'EnableBackpressure', and 'ChunkTimeout', allowing for optimized memory usage and flow control during data streaming operations.

```csharp
public class StreamingConfiguration
{
    public int BufferSize { get; set; } = 8192;
    public int MaxBufferedChunks { get; set; } = 100;
    public bool EnableBackpressure { get; set; } = true;
    public TimeSpan ChunkTimeout { get; set; } = TimeSpan.FromSeconds(30);
}
```

--------------------------------

### IChatRequestBuilder Execution Methods in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet defines the execution methods available on the `IChatRequestBuilder`. These methods allow for asynchronous execution of the built chat request, streaming of chat completion chunks, or simply building the `ChatCompletionRequest` object without immediate execution.

```C#
Task<ChatCompletionResponse> ExecuteAsync(CancellationToken cancellationToken = default);
IAsyncEnumerable<ChatCompletionChunk> ExecuteStreamAsync(CancellationToken cancellationToken = default);
ChatCompletionRequest Build();
```

--------------------------------

### IChatRequestBuilder Usage Tracking Methods in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet provides methods for enabling and configuring usage accounting within `IChatRequestBuilder`. It allows tracking resource consumption for chat completion requests, with options for simple enablement or detailed configuration via a `UsageConfig` action.

```C#
IChatRequestBuilder WithUsageAccounting(bool enabled = true);
IChatRequestBuilder WithUsageAccounting(Action<UsageConfig> configure);
```

--------------------------------

### Accessing OpenRouter Services via IOpenRouterClient in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This C# code snippet defines properties within the `IOpenRouterClient` interface, providing access to specialized services for different OpenRouter API endpoints like chat, models, credits, keys, and authentication. Each property returns an interface specific to its service.

```C#
IChatService Chat { get; }
IModelsService Models { get; }
ICreditsService Credits { get; }
IKeysService Keys { get; }
IAuthService Auth { get; }
```

--------------------------------

### IChatRequestBuilder Tool Integration Methods in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet shows methods for integrating tools within chat completion requests using `IChatRequestBuilder`. It allows specifying a collection of tools and defining the tool choice behavior, enabling the model to interact with external functionalities.

```C#
IChatRequestBuilder WithTools(params Tool[] tools);
IChatRequestBuilder WithToolChoice(object toolChoice);
```

--------------------------------

### Advanced HttpClient Configuration for OpenRouter Client in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

This C# snippet illustrates advanced `HttpClient` configuration, leveraging `OpenRouterOptions` for base URL and timeout, and configuring the primary message handler for connection pooling, connection timeout, and pooled connection lifetime.

```csharp
services.AddHttpClient<IOpenRouterClient, OpenRouterClient>()
    .ConfigureHttpClient((services, client) =>
    {
        var options = services.GetRequiredService<IOptions<OpenRouterOptions>>().Value;
        client.BaseAddress = new Uri(options.BaseUrl);
        client.Timeout = options.HttpTimeout;
    })
    .ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler
    {
        MaxConnectionsPerServer = 10,
        ConnectionTimeout = TimeSpan.FromSeconds(30),
        PooledConnectionLifetime = TimeSpan.FromMinutes(2)
    });
```

--------------------------------

### Discovering Models with OpenRouter C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/README.md

This snippet shows how to retrieve available models from the OpenRouter API using the C# client. It fetches all models and then filters them to find those whose IDs contain 'gpt', useful for identifying specific model families.

```csharp
var models = await client.Models.GetModelsAsync();
var gptModels = models.Data.Where(m => m.Id.Contains("gpt"));
```

--------------------------------

### Calculating Search Result Relevance with RelevanceEngine in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

This C# class defines a `CalculateRelevance` method that computes a composite relevance score for a search result based on multiple weighted factors like keyword match, domain authority, recency, content quality, and user engagement. It also includes a `RankResults` method to order search results by their custom relevance score, providing a flexible ranking mechanism.

```csharp
public class RelevanceEngine
{
    public float CalculateRelevance(SearchResult result, string originalQuery)
    {
        var scores = new[]
        {
            KeywordMatchScore(result, originalQuery) * 0.3f,
            DomainAuthorityScore(result) * 0.2f,
            RecencyScore(result) * 0.2f,
            ContentQualityScore(result) * 0.2f,
            UserEngagementScore(result) * 0.1f
        };
        
        return scores.Sum();
    }
    
    private float KeywordMatchScore(SearchResult result, string query)
    {
        var queryKeywords = ExtractKeywords(query);
        var resultKeywords = ExtractKeywords($"{result.Title} {result.Snippet}");
        
        var matches = queryKeywords.Intersect(resultKeywords, StringComparer.OrdinalIgnoreCase);
        return (float)matches.Count() / queryKeywords.Length;
    }
    
    public SearchResult[] RankResults(SearchResult[] results, string query, RankingCriteria criteria)
    {
        return results
            .Select(r => new { Result = r, Score = CalculateCustomScore(r, query, criteria) })
            .OrderByDescending(x => x.Score)
            .Select(x => x.Result)
            .ToArray();
    }
}
```

--------------------------------

### Handling OpenRouter Exceptions in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/error-handling.md

This C# `try-catch` block demonstrates specific exception handling for `OpenRouter` API calls, differentiating between authentication, rate limit, and validation errors to provide tailored responses like redirection, retries, or user-friendly messages.

```csharp
try
{
    var response = await client.Chat
        .WithModel("gpt-4")
        .WithMessages("Hello, world!")
        .ExecuteAsync();
}
catch (OpenRouterAuthenticationException ex)
{
    // Handle authentication errors - redirect to API key setup
    logger.LogError(ex, "Authentication failed");
    return RedirectToApiKeySetup();
}
catch (OpenRouterRateLimitException ex)
{
    // Handle rate limiting - implement exponential backoff
    logger.LogWarning(ex, "Rate limit exceeded");
    await Task.Delay(ex.RetryAfter ?? TimeSpan.FromMinutes(1));
    return await RetryRequest();
}
catch (OpenRouterValidationException ex)
{
    // Handle validation errors - return user-friendly messages
    logger.LogWarning(ex, "Request validation failed");
    return BadRequest(ex.ValidationErrors);
}
```

--------------------------------

### IChatRequestBuilder Web Search Integration Methods in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet provides methods for integrating web search capabilities into chat completion requests via `IChatRequestBuilder`. It allows enabling web search functionality, either simply or with detailed configuration options through `WebSearchOptions`.

```C#
IChatRequestBuilder WithWebSearch(bool enabled = true);
IChatRequestBuilder WithWebSearch(Action<WebSearchOptions> configure);
```

--------------------------------

### Setting Repetition Penalty in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet demonstrates setting the WithRepetitionPenalty() parameter. A value greater than 1.0 discourages the model from repeating tokens, which can help prevent repetitive or monotonous output.

```C#
builder.WithRepetitionPenalty(1.1);
```

--------------------------------

### Calling Chat Completion Service Directly in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet shows how to use the IChatService interface to send a previously constructed ChatCompletionRequest. It then prints the content of the first choice's message from the asynchronous response.

```C#
var response = await client.Chat.CreateChatCompletionAsync(request);
Console.WriteLine(response.Choices[0].Message.Content);
```

--------------------------------

### Defining IChatService Interface Methods in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet defines the core methods of the `IChatService` interface, providing functionalities for executing chat completion requests asynchronously, streaming chat completion chunks, and creating a fluent request builder for advanced configuration.

```C#
Task<ChatCompletionResponse> CreateAsync(ChatCompletionRequest request, CancellationToken cancellationToken = default);
IAsyncEnumerable<ChatCompletionChunk> CreateStreamAsync(ChatCompletionRequest request, CancellationToken cancellationToken = default);
IChatRequestBuilder CreateRequest();
```

--------------------------------

### Managing Citations with CitationProcessor in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

This C# class provides methods for formatting search results into various citation styles (e.g., APA, MLA, Chicago, Harvard) and generating inline citations based on the relevance of sentences to source material. It helps in attributing sources correctly and creating structured references for search results.

```csharp
public class CitationProcessor
{
    public string FormatCitations(SearchResult[] results, CitationStyle style)
    {
        return style switch
        {
            CitationStyle.APA => FormatAPA(results),
            CitationStyle.MLA => FormatMLA(results),
            CitationStyle.Chicago => FormatChicago(results),
            CitationStyle.Harvard => FormatHarvard(results),
            _ => FormatBasic(results)
        };
    }
    
    private string FormatAPA(SearchResult[] results)
    {
        var citations = results.Select(r => 
            $"{ExtractAuthor(r)}. ({r.PublishedDate.Year}). {r.Title}. " +
            $"Retrieved from {r.Url}");
        
        return string.Join("\n", citations);
    }
    
    public InlineCitation[] GenerateInlineCitations(string response, SearchResult[] sources)
    {
        var citations = new List<InlineCitation>();
        
        foreach (var source in sources)
        {
            var relevantSentences = ExtractRelevantSentences(response, source);
            foreach (var sentence in relevantSentences)
            {
                citations.Add(new InlineCitation
                {
                    Text = sentence,
                    SourceId = source.Url,
                    ConfidenceScore = CalculateRelevance(sentence, source)
                });
            }
        }
        
        return citations.ToArray();
    }
}
```

--------------------------------

### Implementing Search Result Caching in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

This C# class provides a mechanism to cache web search results, improving performance by reducing redundant API calls. It uses `IMemoryCache` to store results and defines cache durations based on search options, ensuring efficient retrieval and expiration of cached data.

```csharp
public class SearchResultCache
{
    private readonly IMemoryCache cache;
    private readonly SearchCacheOptions options;
    
    public SearchResultCache(IMemoryCache cache, SearchCacheOptions options)
    {
        this.cache = cache;
        this.options = options;
    }
    
    public async Task<SearchResult[]> GetOrSearchAsync(string query, WebSearchOptions searchOptions)
    {
        var cacheKey = GenerateCacheKey(query, searchOptions);
        
        if (cache.TryGetValue(cacheKey, out SearchResult[] cachedResults))
        {
            return FilterExpiredResults(cachedResults);
        }
        
        var results = await PerformWebSearch(query, searchOptions);
        
        cache.Set(cacheKey, results, new MemoryCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = GetCacheDuration(searchOptions),
            SlidingExpiration = options.SlidingExpiration,
            Priority = CacheItemPriority.Normal
        });
        
        return results;
    }
    
    private TimeSpan GetCacheDuration(WebSearchOptions options)
    {
        return options.TimeRange switch
        {
            TimeRange.LastHour => TimeSpan.FromMinutes(5),
            TimeRange.LastDay => TimeSpan.FromMinutes(30),
            TimeRange.LastWeek => TimeSpan.FromHours(2),
            TimeRange.LastMonth => TimeSpan.FromHours(6),
            _ => TimeSpan.FromHours(1)
        };
    }
}
```

--------------------------------

### Handling Conversational Tool Calls in OpenRouter Chat API (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

Illustrates a continuous conversation loop that integrates tool calling. It sends user messages, processes model responses, identifies tool calls, executes them, and appends tool results back to the conversation, allowing the model to continue the dialogue based on tool outputs.

```csharp
public async Task<string> HandleConversationWithTools(string userMessage)
{
    var messages = new List<ChatMessage> { new("user", userMessage) };
    
    while (true)
    {
        var response = await client.Chat
            .WithModel("gpt-4")
            .WithMessages(messages)
            .WithTools(availableTools)
            .ExecuteAsync();
            
        messages.Add(response.Choices[0].Message);
        
        if (response.Choices[0].Message.ToolCalls?.Any() == true)
        {
            foreach (var toolCall in response.Choices[0].Message.ToolCalls)
            {
                var result = await ExecuteToolCall(toolCall);
                messages.Add(new ChatMessage("tool", result)
                {
                    ToolCallId = toolCall.Id
                });
            }
        }
        else
        {
            return response.Choices[0].Message.Content;
        }
    }
}
```

--------------------------------

### Injecting Specific OpenRouter Services in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This C# class demonstrates how to inject specific OpenRouter services (IModelsService, ICreditsService) into a custom service. It shows how to retrieve available models and filter them based on the user's credit balance, illustrating a common pattern for consuming individual API functionalities.

```C#
public class ModelService
{
    private readonly IModelsService _modelsService;
    private readonly ICreditsService _creditsService;

    public ModelService(
        IModelsService modelsService,
        ICreditsService creditsService)
    {
        _modelsService = modelsService;
        _creditsService = creditsService;
    }

    public async Task<AvailableModel[]> GetAffordableModelsAsync(
        CancellationToken cancellationToken = default)
    {
        var credits = await _creditsService.GetCreditsAsync(cancellationToken);
        var models = await _modelsService.GetModelsAsync(cancellationToken);

        return models
            .Where(m => m.Pricing.Prompt <= credits.Balance)
            .ToArray();
    }
}
```

--------------------------------

### Executing Multiple C# Tools in Parallel

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

This C# asynchronous method shows how to execute multiple tool calls concurrently using `Task.WhenAll`. It transforms each `ToolCall` into an asynchronous execution task, waits for all tasks to complete, and then aggregates their results into a list of `ChatMessage` objects. It depends on an `IToolExecutor` instance.

```csharp
public async Task<List<ChatMessage>> ExecuteToolsInParallel(IEnumerable<ToolCall> toolCalls)
{
    var tasks = toolCalls.Select(async toolCall =>
    {
        var result = await toolExecutor.ExecuteAsync(toolCall);
        return new ChatMessage("tool", result) { ToolCallId = toolCall.Id };
    });
    
    var results = await Task.WhenAll(tasks);
    return results.ToList();
}
```

--------------------------------

### Conducting Research with AI-Powered Web Search in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

This C# class facilitates automated research by integrating with an AI chat client and web search capabilities. It configures search options based on the research scope (e.g., academic, industry, news) and processes the AI response to extract summaries, sources, and key findings.

```csharp
public class ResearchAssistant
{
    public async Task<ResearchSummary> ConductResearch(string topic, ResearchScope scope)
    {
        var searchOptions = ConfigureResearchSearch(scope);
        
        var response = await client.Chat
            .WithModel("gpt-4")
            .WithMessages($"Conduct comprehensive research on: {topic}")
            .WithWebSearch(searchOptions)
            .ExecuteAsync();
            
        return new ResearchSummary
        {
            Topic = topic,
            Summary = response.Choices[0].Message.Content,
            Sources = ExtractSources(response),
            KeyFindings = ExtractKeyFindings(response),
            ResearchDate = DateTime.UtcNow
        };
    }
    
    private WebSearchOptions ConfigureResearchSearch(ResearchScope scope)
    {
        return scope switch
        {
            ResearchScope.Academic => new WebSearchOptions
            {
                MaxResults = 20,
                ContentType = ContentType.Academic,
                AllowedDomains = new[] { "scholar.google.com", "pubmed.ncbi.nlm.nih.gov", "jstor.org" },
                VerifySourceCredibility = true
            },
            ResearchScope.Industry => new WebSearchOptions
            {
                MaxResults = 15,
                ContentType = ContentType.Articles,
                TimeRange = TimeRange.LastYear,
                MinDomainAuthority = DomainAuthority.High
            },
            ResearchScope.News => new WebSearchOptions
            {
                MaxResults = 10,
                ContentType = ContentType.News,
                TimeRange = TimeRange.LastMonth
            },
            _ => new WebSearchOptions()
        };
    }
}
```

--------------------------------

### Defining Web Search Options in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

This C# class defines a comprehensive set of parameters for configuring web searches, allowing control over result count, ranking, time ranges, allowed/blocked domains, content types, keywords, language, safety, source credibility, and content length. It also includes options for response integration like citations and summarization. The associated enums, TimeRange and ContentType, provide predefined options for temporal and content-specific filtering.

```C#
public class WebSearchOptions
{
    // Result Control
    public int MaxResults { get; set; } = 5;
    public SearchRanking RankBy { get; set; } = SearchRanking.Relevance;
    
    // Time Filtering
    public TimeRange TimeRange { get; set; } = TimeRange.AnyTime;
    public DateTime? CustomStartDate { get; set; }
    public DateTime? CustomEndDate { get; set; }
    
    // Domain Filtering
    public string[] AllowedDomains { get; set; }
    public string[] BlockedDomains { get; set; }
    public DomainAuthority MinDomainAuthority { get; set; } = DomainAuthority.Any;
    
    // Content Filtering
    public ContentType ContentType { get; set; } = ContentType.All;
    public string[] RequiredKeywords { get; set; }
    public string[] ExcludedKeywords { get; set; }
    public SearchLanguage Language { get; set; } = SearchLanguage.English;
    
    // Quality Control
    public SearchSafety SafetyLevel { get; set; } = SearchSafety.Moderate;
    public bool VerifySourceCredibility { get; set; } = true;
    public int MinContentLength { get; set; } = 100;
    
    // Response Integration
    public bool IncludeCitations { get; set; } = true;
    public bool SummarizeResults { get; set; } = true;
    public CitationStyle CitationStyle { get; set; } = CitationStyle.APA;
}

public enum TimeRange
{
    AnyTime,
    LastHour,
    LastDay,
    LastWeek,
    LastMonth,
    LastYear,
    Custom
}

public enum ContentType
{
    All,
    Articles,
    News,
    Academic,
    Videos,
    Images,
    PDFs,
    Forums
}
```

--------------------------------

### IChatRequestBuilder Generation Parameters in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet lists various methods within `IChatRequestBuilder` for fine-tuning AI model generation parameters. These parameters control aspects like creativity (temperature), response length (max tokens), token sampling (topP, topK, minP, topA), and repetition control (frequency, presence, repetition penalties, seed) to influence the output.

```C#
IChatRequestBuilder WithTemperature(double temperature);
IChatRequestBuilder WithMaxTokens(int maxTokens);
IChatRequestBuilder WithTopP(double topP);
IChatRequestBuilder WithTopK(int topK);
IChatRequestBuilder WithFrequencyPenalty(double penalty);
IChatRequestBuilder WithPresencePenalty(double penalty);
IChatRequestBuilder WithRepetitionPenalty(double penalty);
IChatRequestBuilder WithMinP(double minP);
IChatRequestBuilder WithTopA(double topA);
IChatRequestBuilder WithSeed(int seed);
```

--------------------------------

### Integrating OpenRouter with Custom HttpClient (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This snippet demonstrates `AddOpenRouterWithHttpClient()`, which allows custom configuration of the underlying `HttpClient`. It leverages `IServiceCollection.AddHttpClient<T>()` for proper lifecycle management, enabling custom timeouts, default headers, and integration with `HttpClientFactory`.

```C#
builder.Services.AddOpenRouterWithHttpClient(
    configure: options =>
    {
        options.ApiKey = builder.Configuration["OpenRouter:ApiKey"]!;
        options.BaseUrl = "https://openrouter.ai/api/v1";
    },
    configureHttpClient: client =>
    {
        client.Timeout = TimeSpan.FromSeconds(60);
        client.DefaultRequestHeaders.Add("User-Agent", "MyApp/1.0");
        client.DefaultRequestHeaders.Add("X-Custom-Header", "CustomValue");
    });
```

--------------------------------

### Executing Streaming Chat Requests (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/streaming.md

This code shows how to execute a previously configured streaming chat request using `ExecuteStreamAsync()`. It iterates over incoming chunks, extracting and printing the delta content to the console as it arrives, providing real-time output.

```csharp
await foreach (var chunk in streamBuilder.ExecuteStreamAsync())
{
    if (chunk.Choices?.FirstOrDefault()?.Delta?.Content != null)
    {
        Console.Write(chunk.Choices[0].Delta.Content);
    }
}
```

--------------------------------

### Properties for ImageUrl Model (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Defines the properties for specifying an image URL within multi-modal content. `Url` holds the image's location, and `Detail` provides an optional hint for image quality or processing preference (e.g., 'low', 'high', 'auto').

```C#
string Url { get; set; } = string.Empty;
string? Detail { get; set; }  // "low", "high", or "auto"
```

--------------------------------

### Loading OpenRouter API Key from Environment Variable in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This code illustrates how to retrieve the OpenRouter API key from an environment variable named OPENROUTER_API_KEY. It uses Environment.GetEnvironmentVariable and throws an InvalidOperationException if the variable is not set, ensuring secure and flexible API key management.

```csharp
// Use environment variables
builder.Services.AddOpenRouter(options =>
{
    options.ApiKey = Environment.GetEnvironmentVariable("OPENROUTER_API_KEY")
        ?? throw new InvalidOperationException("OPENROUTER_API_KEY not set");
    
    // Other configuration from appsettings
    builder.Configuration.GetSection("OpenRouter").Bind(options);
});
```

--------------------------------

### Setting System Message with Fluent Builder in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet shows how to use the WithSystemMessage() method of the chat request builder. This method is used to define the system's role or initial instructions for the language model, influencing its overall behavior.

```C#
builder.WithSystemMessage("You are a helpful assistant specialized in programming.");
```

--------------------------------

### Managing Multi-turn AI Conversations in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

This C# class `ConversationManager` handles the state of multi-turn conversations with an AI model. It processes user messages, integrates AI responses, and manages tool calls, preventing infinite loops by limiting conversation turns. It relies on `ChatMessage` and `ToolExecutor` for core functionality.

```C#
public class ConversationManager
{
    private readonly List<ChatMessage> conversationHistory = new();
    private readonly ToolExecutor toolExecutor;
    
    public async Task<string> ProcessUserMessage(string message)
    {
        conversationHistory.Add(new ChatMessage("user", message));
        
        var maxTurns = 10; // Prevent infinite loops
        var turnCount = 0;
        
        while (turnCount < maxTurns)
        {
            var response = await GetAIResponse();
            conversationHistory.Add(response.Choices[0].Message);
            
            if (response.Choices[0].Message.ToolCalls?.Any() == true)
            {
                await ProcessToolCalls(response.Choices[0].Message.ToolCalls);
                turnCount++;
            }
            else
            {
                return response.Choices[0].Message.Content;
            }
        }
        
        return "Conversation exceeded maximum turns.";
    }
    
    private async Task ProcessToolCalls(IEnumerable<ToolCall> toolCalls)
    {
        foreach (var toolCall in toolCalls)
        {
            var result = await toolExecutor.ExecuteToolCall(toolCall);
            conversationHistory.Add(new ChatMessage("tool", result)
            {
                ToolCallId = toolCall.Id
            });
        }
    }
}
```

--------------------------------

### Provider and Feature Settings for ChatCompletionRequest (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Allows specifying provider-specific preferences and enabling additional features like reasoning, usage tracking, and web search integration. These properties extend the request's capabilities beyond standard chat completion.

```C#
ProviderPreferences? Provider { get; set;}
ReasoningConfig? Reasoning { get; set;}
UsageConfig? Usage { get; set;}
WebSearchOptions? WebSearch { get; set;}
```

--------------------------------

### Implementing Exponential Backoff Retry in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/error-handling.md

This C# method `ExecuteWithRetry` implements an exponential backoff strategy for retrying operations that might fail due to `OpenRouterRateLimitException` or `OpenRouterNetworkException`. It progressively increases the delay between retries up to a maximum number of attempts.

```csharp
public async Task<T> ExecuteWithRetry<T>(Func<Task<T>> operation, int maxRetries = 3)
{
    var retryCount = 0;
    var delay = TimeSpan.FromSeconds(1);

    while (retryCount < maxRetries)
    {
        try
        {
            return await operation();
        }
        catch (OpenRouterRateLimitException ex)
        {
            retryCount++;
            var retryDelay = ex.RetryAfter ?? delay;
            
            if (retryCount >= maxRetries)
                throw;
                
            await Task.Delay(retryDelay);
            delay = TimeSpan.FromMilliseconds(delay.TotalMilliseconds * 2); // Exponential backoff
        }
        catch (OpenRouterNetworkException ex) when (retryCount < maxRetries)
        {
            retryCount++;
            await Task.Delay(delay);
            delay = TimeSpan.FromMilliseconds(delay.TotalMilliseconds * 2);
        }
    }

    throw new InvalidOperationException("Maximum retry attempts exceeded");
}
```

--------------------------------

### Monitoring Current Events with GPT-4 and Web Search (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

This C# class `CurrentEventMonitor` provides functionality to retrieve and summarize the latest events on specified topics using an AI model (GPT-4) integrated with web search. It dynamically adjusts search parameters like `MaxResults`, `ContentType`, `TimeRange`, and `AllowedDomains` based on the `EventPriority`. It returns an array of `EventSummary` objects containing the topic, AI-generated summary, priority, and last updated timestamp.

```csharp
public class CurrentEventMonitor
{
    public async Task<EventSummary[]> GetLatestEvents(string[] topics, EventPriority priority)
    {
        var summaries = new List<EventSummary>();
        
        foreach (var topic in topics)
        {
            var searchOptions = new WebSearchOptions
            {
                MaxResults = priority == EventPriority.High ? 15 : 8,
                ContentType = ContentType.News,
                TimeRange = priority == EventPriority.Critical ? TimeRange.LastHour : TimeRange.LastDay,
                AllowedDomains = GetNewsSourcesByPriority(priority)
            };
            
            var response = await client.Chat
                .WithModel("gpt-4")
                .WithMessages($"Summarize the latest developments regarding: {topic}")
                .WithWebSearch(searchOptions)
                .ExecuteAsync();
                
            summaries.Add(new EventSummary
            {
                Topic = topic,
                Summary = response.Choices[0].Message.Content,
                Priority = priority,
                LastUpdated = DateTime.UtcNow
            });
        }
        
        return summaries.ToArray();
    }
}
```

--------------------------------

### Retrieving and Listing All Available Models (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/models.md

This code retrieves all available models from the OpenRouter service and iterates through them, printing each model's ID and name to the console. It showcases basic model discovery and enumeration.

```csharp
var allModels = await client.Models.GetModelsAsync();
foreach (var model in allModels.Data)
{
    Console.WriteLine($"{model.Id} - {model.Name}");
}
```

--------------------------------

### Setting Presence Penalty in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet shows how to set the WithPresencePenalty() parameter. A positive presence penalty reduces the likelihood of the model introducing new tokens that have already appeared in the prompt or previous turns, encouraging novelty.

```C#
builder.WithPresencePenalty(0.6);
```

--------------------------------

### Defining OpenRouter Authentication Service Interface (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This C# snippet defines the `IAuthService` interface, outlining the methods available for managing OAuth authentication flows and PKCE challenges. It includes method signatures for generating authorization URLs, exchanging authorization codes for API keys, and generating PKCE challenges, serving as a contract for authentication service implementations.

```C#
AuthorizationUrl GenerateAuthorizationUrl(OAuthConfig config);
Task<AuthKeyExchangeResponse> ExchangeCodeForKeyAsync(AuthKeyExchangeRequest request, CancellationToken cancellationToken = default);
PKCEChallenge GeneratePKCEChallenge();
```

--------------------------------

### Setting Temperature for Balanced Creativity in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet shows how to set the Temperature parameter to 0.7 using the fluent builder. A temperature of 0.7 typically results in a balanced level of creativity and randomness in the model's responses.

```C#
builder.WithTemperature(0.7); // Balanced creativity
```

--------------------------------

### Automating Fact Verification with Claude-3-Sonnet and Web Search (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

The `FactVerificationEngine` class in C# automates the process of verifying claims using the Claude-3-Sonnet AI model and web search. It configures `WebSearchOptions` to prioritize fact-checking sources, verify source credibility, and search within the last year. The method returns a `VerificationResult` object, parsing the AI's response for verification status, sources, and a confidence level. It includes a helper method `GetFactCheckingSources` to define trusted domains.

```csharp
public class FactVerificationEngine
{
    public async Task<VerificationResult> VerifyFact(string claim)
    {
        var searchOptions = new WebSearchOptions
        {
            MaxResults = 10,
            AllowedDomains = GetFactCheckingSources(),
            VerifySourceCredibility = true,
            TimeRange = TimeRange.LastYear
        };
        
        var response = await client.Chat
            .WithModel("claude-3-sonnet")
            .WithMessages($"Verify this claim with authoritative sources: {claim}")
            .WithWebSearch(searchOptions)
            .ExecuteAsync();
            
        return new VerificationResult
        {
            Claim = claim,
            Verification = ParseVerificationResult(response),
            Sources = ExtractSources(response),
            ConfidenceLevel = CalculateConfidence(response)
        };
    }
    
    private string[] GetFactCheckingSources()
    {
        return new[]
        {
            "factcheck.org",
            "snopes.com",
            "politifact.com",
            "reuters.com/fact-check",
            "apnews.com/hub/ap-fact-check"
        };
    }
}
```

--------------------------------

### Defining Tool and Function Models in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

This C# code defines the `Tool` and `Function` classes, which are fundamental for structuring tool definitions in the OpenRouter .NET library. The `Tool` class specifies the type (defaulting to 'function') and holds a `Function` object, while the `Function` class defines the name, description, and parameters for a callable function.

```C#
public class Tool
{
    public string Type { get; set; } = "function";
    public Function Function { get; set; }
}

public class Function
{
    public string Name { get; set; }
    public string Description { get; set; }
    public object Parameters { get; set; }
}
```

--------------------------------

### Implementing Custom Authentication Provider in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

This C# code defines a custom authentication provider by implementing `IAuthenticationProvider`. It retrieves a valid token using `ICustomTokenService` and formats it as a Bearer token, including error logging and disposal logic. The snippet also shows how to register this custom provider as a singleton in the service collection for dependency injection.

```C#
public class CustomAuthenticationProvider : IAuthenticationProvider
{
    private readonly ICustomTokenService _tokenService;
    private readonly ILogger<CustomAuthenticationProvider> _logger;

    public CustomAuthenticationProvider(
        ICustomTokenService tokenService,
        ILogger<CustomAuthenticationProvider> logger)
    {
        _tokenService = tokenService;
        _logger = logger;
    }

    public async Task<string> GetAuthorizationHeaderAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            var token = await _tokenService.GetValidTokenAsync(cancellationToken);
            return $"Bearer {token}";
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to retrieve authentication token");
            throw new AuthenticationException("Unable to authenticate request", ex);
        }
    }

    public void Dispose()
    {
        _tokenService?.Dispose();
    }
}

// Register custom provider
services.AddSingleton<IAuthenticationProvider, CustomAuthenticationProvider>();
```

--------------------------------

### Defining UsageConfig Properties in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This snippet defines the properties of the `UsageConfig` class, which controls how API usage is tracked and reported. It includes options to enable or disable usage tracking, `TrackCosts` for financial reporting, and `IncludeReasoning` to incorporate reasoning-related costs.

```csharp
bool? Enabled { get; set; }
bool? TrackCosts { get; set; }
bool? IncludeReasoning { get; set;}
```

--------------------------------

### Constructor for OpenRouterAuthenticationException in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

Provides the constructor for OpenRouterAuthenticationException, used when API key authentication fails, allowing instantiation with a descriptive message and an optional requestId for tracking.

```C#
public OpenRouterAuthenticationException(string message, string? requestId = null);
```

--------------------------------

### Verifying Runtime Schema Compliance in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/structured-outputs.md

This C# class provides functionality to verify if a given object `T` complies with a specified JSON schema at runtime. It serializes the response and schema to JSON, parses them into `JsonDocument`s, and then calls an internal method to perform the actual schema validation logic.

```C#
public class SchemaComplianceChecker
{
    public bool VerifyCompliance<T>(T response, object schema)
    {
        var responseJson = JsonSerializer.Serialize(response);
        var responseDocument = JsonDocument.Parse(responseJson);
        
        return ValidateAgainstSchema(responseDocument.RootElement, schema);
    }
    
    private bool ValidateAgainstSchema(JsonElement element, object schema)
    {
        var schemaJson = JsonSerializer.Serialize(schema);
        var schemaDocument = JsonDocument.Parse(schemaJson);
        
        // Implement JSON Schema validation logic
        return PerformSchemaValidation(element, schemaDocument.RootElement);
    }
}
```

--------------------------------

### Accessing OpenRouter Credits Service in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/credits.md

This snippet demonstrates how to obtain an instance of the ICreditsService from the OpenRouter client and asynchronously retrieve the current credit balance. It serves as the initial step for any credit-related operations.

```C#
var creditsService = client.Credits;
var balance = await creditsService.GetCreditsAsync();
```

--------------------------------

### Constructing OpenRouterProviderException (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This C# constructor for `OpenRouterProviderException` allows initializing the exception with a message, an optional provider name, an optional status code (defaulting to 502), and an optional request ID. It is used when issues originate from an upstream provider, such as their API being unavailable or rate limits being hit.

```csharp
public OpenRouterProviderException(string message, string? providerName = null, int statusCode = 502, string? requestId = null);
```

--------------------------------

### Configuring Corporate Proxy for HttpClient in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

This C# snippet shows how to configure an `HttpClient` to use a corporate proxy. It sets `UseProxy` to true and specifies the proxy address, along with using default network credentials for authentication.

```csharp
services.AddHttpClient<IOpenRouterClient, OpenRouterClient>()
    .ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler
    {
        UseProxy = true,
        Proxy = new WebProxy("http://corporate-proxy:8080")
        {
            Credentials = CredentialCache.DefaultNetworkCredentials
        }
    });
```

--------------------------------

### Constructors for OpenRouterException in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

Provides various constructors for OpenRouterException, allowing instantiation with a message, an inner exception, and optional errorCode, statusCode, and requestId parameters for detailed error reporting.

```C#
protected OpenRouterException(string message);
protected OpenRouterException(string message, Exception innerException);
protected OpenRouterException(string message, string? errorCode = null, int? statusCode = null, string? requestId = null);
protected OpenRouterException(string message, Exception innerException, string? errorCode = null, int? statusCode = null, string? requestId = null);
```

--------------------------------

### Refreshing Access Token (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/oauth.md

This method demonstrates how to refresh an expired access token using a refresh token. It creates a `TokenRefreshRequest` with the existing refresh token and then calls `RefreshTokenAsync` to obtain a new access token.

```C#
public async Task<string> RefreshAccessToken(string refreshToken)
{
    var refreshRequest = new TokenRefreshRequest
    {
        RefreshToken = refreshToken
    };

    var response = await client.Auth.RefreshTokenAsync(refreshRequest);
    return response.AccessToken;
}
```

--------------------------------

### Secure API Key Storage Best Practices (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/api-keys.md

This snippet highlights critical security best practices for storing API keys, emphasizing that keys should never be hardcoded. It demonstrates retrieving keys from environment variables and suggests using dedicated secure key vaults like Azure Key Vault or AWS Secrets Manager for production environments.

```csharp
// DO NOT store keys in code
// Use environment variables or secure key vaults
var apiKey = Environment.GetEnvironmentVariable("OPENROUTER_API_KEY");

// Use Azure Key Vault, AWS Secrets Manager, or similar
var keyVaultSecret = await keyVaultClient.GetSecretAsync("openrouter-api-key");
```

--------------------------------

### Properties for DocumentUrl Model (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Defines the properties for specifying a document URL within multi-modal content. `Url` holds the document's location, and `Type` provides an optional hint for the document's format (e.g., 'pdf', 'docx').

```C#
string Url { get; set; } = string.Empty;
string? Type { get; set; }  // "pdf", "docx", etc.
```

--------------------------------

### Accessing Keys Service in OpenRouter Client (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/api-keys.md

This snippet demonstrates how to access the API keys service through the OpenRouter client instance to initiate key management operations, such as retrieving existing keys.

```csharp
var keysService = client.Keys;
var keys = await keysService.GetKeysAsync();
```

--------------------------------

### Testing JSON Schema Generation and Validation in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/structured-outputs.md

This C# class provides methods for testing JSON schema generation and validation. 'ValidateSchemaGeneration' verifies that a generated schema correctly validates sample data, while 'TestSchemaRoundTrip' ensures that data can be serialized to JSON using the schema and then deserialized back into the original C# type without loss of fidelity.

```csharp
public class SchemaTestFramework
{
    public void ValidateSchemaGeneration<T>(T sampleData)
    {
        // Generate schema from type
        var schema = JsonSchemaGenerator.Generate<T>();
        
        // Serialize sample data
        var json = JsonSerializer.Serialize(sampleData);
        
        // Validate sample data against generated schema
        var isValid = ValidateJsonAgainstSchema(json, schema);
        
        if (!isValid)
            throw new SchemaValidationException(
                $"Generated schema for {typeof(T).Name} does not validate sample data");
    }
    
    public void TestSchemaRoundTrip<T>(T originalData)
    {
        // Generate schema
        var schema = JsonSchemaGenerator.Generate<T>();
        
        // Use schema in structured output
        var response = SimulateStructuredResponse(schema, originalData);
        
        // Deserialize and compare
        var deserializedData = JsonSerializer.Deserialize<T>(response);
        
        AssertEquivalent(originalData, deserializedData);
    }
}
```

--------------------------------

### Logging Configuration in OpenRouterOptions (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This C# code defines properties within the `OpenRouterOptions` class for configuring logging behavior. `EnableLogging` controls whether logging is active, and `LogLevel` sets the minimum level of messages to be logged, both with default values.

```C#
bool EnableLogging { get; set; } = true;
LogLevel LogLevel { get; set; } = LogLevel.Information;
```

--------------------------------

### Generation Parameters for ChatCompletionRequest (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Provides parameters to control the text generation process, influencing creativity, length, and diversity. Properties like `Temperature`, `MaxTokens`, `TopP`, and `TopK` adjust the sampling strategy and output constraints.

```C#
double? Temperature { get; set;}
int? MaxTokens { get; set;}
double? TopP { get; set;}
int? TopK { get; set;}
double? FrequencyPenalty { get; set;}
double? PresencePenalty { get; set;}
double? RepetitionPenalty { get; set;}
double? MinP { get; set;}
double? TopA { get; set;}
int? Seed { get; set;}
```

--------------------------------

### Default OpenRouter Service Lifetimes in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This snippet outlines the default dependency injection lifetimes used for OpenRouter services. It shows TryAddSingleton for core components like OpenRouterOptions, IAuthenticationProvider, and IHttpClientProvider (shared across the application), and TryAddScoped for request-specific services like IChatService and IOpenRouterClient (per request in web apps).

```csharp
// Singleton (shared across application)
services.TryAddSingleton<OpenRouterOptions>();
services.TryAddSingleton<IAuthenticationProvider>();
services.TryAddSingleton<IHttpClientProvider>();

// Scoped (per request in web apps, per scope otherwise)
services.TryAddScoped<IChatService>();
services.TryAddScoped<IModelsService>();
services.TryAddScoped<ICreditsService>();
services.TryAddScoped<IKeysService>();
services.TryAddScoped<IAuthService>();
services.TryAddScoped<IOpenRouterClient>();
```

--------------------------------

### Accessing Model Operations with OpenRouter Client (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/models.md

This snippet demonstrates how to access the `IModelsService` through the OpenRouter client to retrieve a list of available models asynchronously. It initializes the models service and then calls `GetModelsAsync`.

```csharp
var modelsService = client.Models;
var models = await modelsService.GetModelsAsync();
```

--------------------------------

### Adding User Message with Fluent Builder in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet demonstrates the WithUserMessage() method, which adds a user's input to the conversation history. This is typically the prompt or question the user wants the model to respond to.

```C#
builder.WithUserMessage("Explain dependency injection in .NET");
```

--------------------------------

### Implementing Low Credit Balance Detection in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/credits.md

This C# method demonstrates how to check if the current OpenRouter credit balance falls below a specified threshold. It's designed to facilitate the implementation of automated alerts or actions when credits are running low, ensuring continuous service availability.

```C#
public async Task<bool> CheckLowCreditAlert(decimal threshold = 5.0m)
{
    var credits = await client.Credits.GetCreditsAsync();
    return credits.Data.Balance < threshold;
}
```

--------------------------------

### Tool Integration Properties for ChatCompletionRequest (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Specifies properties for integrating tools into the chat completion process. `Tools` allows defining an array of available functions, and `ToolChoice` controls how the model uses these tools (e.g., 'auto', 'none', or a specific tool).

```C#
Tool[]? Tools { get; set;}
object? ToolChoice { get; set;}
```

--------------------------------

### IChatRequestBuilder Structured Output Methods in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet details methods for configuring structured output from chat completions using `IChatRequestBuilder`. It allows specifying a generic type `T` or a JSON schema to ensure the model's response adheres to a predefined structure.

```C#
IChatRequestBuilder WithStructuredOutput<T>() where T : class;
IChatRequestBuilder WithStructuredOutput(object jsonSchema);
```

--------------------------------

### Enabling Streaming with OpenRouter Chat Request (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/streaming.md

This snippet demonstrates how to enable streaming for a chat request using the `WithStreaming()` method. It configures a chat request with a specific model and user message, setting the streaming option to true for real-time response processing.

```csharp
var streamBuilder = client.Chat.CreateRequest()
    .WithModel("anthropic/claude-3-haiku")
    .WithUserMessage("Write a long story about space exploration")
    .WithStreaming(true);
```

--------------------------------

### Defining ReasoningConfig Properties in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This snippet defines the properties of the `ReasoningConfig` class, which configures the generation of reasoning tokens by the model. It includes options to enable or disable reasoning, set a `MaxTokens` limit for reasoning output, and `IncludeReasoning` in the final response.

```csharp
bool? Enabled { get; set; }
int? MaxTokens { get; set; }
bool? IncludeReasoning { get; set;}
```

--------------------------------

### Implementing Generic Constraints for Structured Output Extensions in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/structured-outputs.md

This C# snippet defines an extension method WithStructuredOutput<T> for IChatRequestBuilder, demonstrating the use of generic constraints (where T : class, new()). These constraints ensure that the type T used for structured output is a reference type and has a parameterless constructor, which is necessary for the JsonSchemaGenerator to create a valid schema.

```C#
public static class StructuredOutputExtensions
{
    public static IChatRequestBuilder WithStructuredOutput<T>(
        this IChatRequestBuilder builder) 
        where T : class, new()
    {
        var schema = JsonSchemaGenerator.Generate<T>();
        return builder.WithStructuredOutput(schema);
    }
}
```

--------------------------------

### Authentication Settings in OpenRouterOptions (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This C# code defines properties within the `OpenRouterOptions` class for configuring authentication settings. `ApiKey` stores the API key, and `ValidateApiKey` controls whether the API key should be validated, with default values provided.

```C#
string ApiKey { get; set; } = string.Empty;
bool ValidateApiKey { get; set; } = true;
```

--------------------------------

### Defining Product Schema with C# Attributes

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/structured-outputs.md

This C# code defines a 'Product' class and 'ProductCategory' enum, demonstrating how attributes like JsonSchema, JsonRequired, JsonPropertyName, StringLength, Range, MaxLength, and JsonConverter are used to control JSON serialization and schema generation, enforcing data types, validation rules, and naming conventions.

```csharp
[JsonSchema(Title = "Product Information", Description = "Complete product details")]
public class Product
{
    [JsonRequired]
    [JsonPropertyName("product_id")]
    [StringLength(50)]
    public string Id { get; set; }
    
    [JsonRequired]
    [StringLength(200)]
    public string Name { get; set; }
    
    [Range(0.01, 999999.99)]
    public decimal Price { get; set; }
    
    [JsonPropertyName("in_stock")]
    public bool InStock { get; set; }
    
    [MaxLength(1000)]
    public string Description { get; set; }
    
    [JsonConverter(typeof(JsonStringEnumConverter))]
    public ProductCategory Category { get; set; }
    
    [JsonPropertyName("created_at")]
    [JsonFormat("date-time")]
    public DateTime CreatedAt { get; set; }
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum ProductCategory
{
    Electronics,
    Clothing,
    Books,
    Home,
    Sports
}
```

--------------------------------

### Constructors for OpenRouterApiException in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

Defines constructors for OpenRouterApiException, enabling creation with a message, HTTP status code, and optional errorCode, requestId, and errorDetails for comprehensive API error representation.

```C#
public OpenRouterApiException(string message, int statusCode, string? errorCode = null, string? requestId = null, object? errorDetails = null);
public OpenRouterApiException(string message, Exception innerException, int statusCode, string? errorCode = null, string? requestId = null, object? errorDetails = null);
```

--------------------------------

### Chaining Chat Completion Requests in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/fluent-api.md

This snippet demonstrates how to chain methods using the IChatRequestBuilder interface to construct a chat completion request. It shows setting the model, messages, maximum tokens, and temperature before executing the request asynchronously to retrieve the chat completion response.

```csharp
var response = await client.Chat
    .WithModel("anthropic/claude-3-sonnet")
    .WithMessages(messages)
    .WithMaxTokens(1000)
    .WithTemperature(0.7)
    .ExecuteAsync();
```

--------------------------------

### Performing Streaming Chat Completion with OpenRouter - C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/README.md

This C# snippet shows how to initiate a streaming chat completion request using the OpenRouter client. It sends a user message to a specified model and asynchronously iterates over the response chunks, printing the delta content as it arrives.

```C#
await foreach (var chunk in client.Chat
    .CreateRequest()
    .WithModel("openai/gpt-4o")
    .AddUserMessage("Tell me a story")
    .WithStreaming(true)
    .SendStreamAsync())
{
    Console.Write(chunk.GetDeltaContent());
}
```

--------------------------------

### IAuthService Interface Definition (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Defines the IAuthService interface, which outlines methods for handling the OAuth PKCE flow. This includes methods for authorization, generating authorization URLs, and exchanging authorization codes for tokens, providing the contract for OAuth operations within the library.

```C#
public interface IAuthService
{
    Task<AuthResponse> AuthorizeAsync(AuthRequest request, CancellationToken cancellationToken = default);
    Task<string> GenerateAuthorizationUrlAsync(string clientId, string redirectUri, string[] scopes, string? state = null);
    Task<AuthResponse> ExchangeCodeForTokenAsync(string code, string clientId, string redirectUri, string codeVerifier, CancellationToken cancellationToken = default);
}
```

--------------------------------

### Injecting OpenRouterClient into ASP.NET Core Controller in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This snippet illustrates how to inject IOpenRouterClient and ILogger into an ASP.NET Core controller's constructor for use in API endpoints. It demonstrates a CreateChatCompletion POST endpoint that utilizes the injected client to send a chat completion request, including error handling for API-specific and unexpected exceptions.

```csharp
[ApiController]
[Route("api/[controller]")]
public class ChatController : ControllerBase
{
    private readonly IOpenRouterClient _openRouterClient;
    private readonly ILogger<ChatController> _logger;

    public ChatController(
        IOpenRouterClient openRouterClient,
        ILogger<ChatController> logger)
    {
        _openRouterClient = openRouterClient;
        _logger = logger;
    }

    [HttpPost("complete")]
    public async Task<ActionResult<ChatCompletionResponse>> CreateChatCompletion(
        [FromBody] ChatCompletionRequest request)
    {
        try
        {
            var response = await _openRouterClient.Chat
                .CreateChatCompletion(request.Model)
                .AddUserMessage(request.Message)
                .SendAsync();

            return Ok(response);
        }
        catch (OpenRouterException ex)
        {
            _logger.LogError(ex, "OpenRouter API error: {Message}", ex.Message);
            return BadRequest(new { error = ex.Message });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during chat completion");
            return StatusCode(500, new { error = "Internal server error" });
        }
    }
}
```

--------------------------------

### Constructor for OpenRouterRateLimitException in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

Provides the constructor for OpenRouterRateLimitException, used when API rate limits are exceeded, allowing instantiation with a message, optional retryAfter duration, and requestId.

```C#
public OpenRouterRateLimitException(string message, TimeSpan? retryAfter = null, string? requestId = null);
```

--------------------------------

### Configuring Provider Routing for Chat Requests (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/models.md

This snippet demonstrates how to configure provider routing preferences for a chat request using `WithProviderRouting()`. It allows specifying preferred providers like 'anthropic' and 'openai' and enabling fallback if preferred providers are unavailable, ensuring robust request handling.

```csharp
var response = await client.Chat.CreateRequest()
    .WithModel("anthropic/claude-3-haiku")
    .WithProviderRouting(routing =>
    {
        routing.PreferredProviders = new[] { "anthropic", "openai" };
        routing.AllowFallback = true;
    })
    .WithUserMessage("Hello, world!")
    .ExecuteAsync();
```

--------------------------------

### Executing AI Tools Asynchronously with Cancellation in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

This C# class `AsyncToolExecutor` provides a robust mechanism for executing AI tool calls asynchronously with built-in cancellation and timeout support. It combines an external cancellation token with an internal timeout token, ensuring that long-running tool executions can be gracefully cancelled or timed out, returning a serialized error message on timeout.

```C#
public class AsyncToolExecutor
{
    public async Task<string> ExecuteAsync(
        ToolCall toolCall, 
        CancellationToken cancellationToken = default)
    {
        using var timeoutCts = new CancellationTokenSource(TimeSpan.FromMinutes(2));
        using var combinedCts = CancellationTokenSource.CreateLinkedTokenSource(
            cancellationToken, timeoutCts.Token);
            
        try
        {
            return await ExecuteToolInternal(toolCall, combinedCts.Token);
        }
        catch (OperationCanceledException) when (timeoutCts.Token.IsCancellationRequested)
        {
            return JsonSerializer.Serialize(new { error = "Tool execution timeout" });
        }
    }
    
    private async Task<string> ExecuteToolInternal(ToolCall toolCall, CancellationToken ct)
    {
        // Long-running tool execution with cancellation support
        await Task.Delay(100, ct); // Simulated work
        return "Tool result";
    }
}
```

--------------------------------

### Defining ProviderPreferences Properties in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This snippet defines the properties of the `ProviderPreferences` class, used to configure how the OpenRouter API routes requests to different providers. It includes options for specifying provider `Order`, `AllowFallbacks`, `RequireParameters`, `DataCollection` preferences, and filtering providers via `Only`, `Ignore`, `Quantizations`, `Sort`, and `MaxPrice` limits.

```csharp
string[]? Order { get; set; }
bool? AllowFallbacks { get; set; }
bool? RequireParameters { get; set; }
string? DataCollection { get; set; }
string[]? Only { get; set; }
string[]? Ignore { get; set; }
string[]? Quantizations { get; set; }
string? Sort { get; set; }
PricingLimits? MaxPrice { get; set;}
```

--------------------------------

### Loading OpenRouter API Key from Secret Manager in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/dependency-injection.md

This snippet shows how to load the OpenRouter API key using ASP.NET Core's Secret Manager, typically used during development. It accesses the key via builder.Configuration["OpenRouter:ApiKey"] and ensures it's configured, providing a secure way to manage secrets without committing them to source control.

```csharp
// Use Secret Manager in development
// Run: dotnet user-secrets set "OpenRouter:ApiKey" "your_api_key"
builder.Services.AddOpenRouter(options =>
{
    options.ApiKey = builder.Configuration["OpenRouter:ApiKey"]
        ?? throw new InvalidOperationException("OpenRouter:ApiKey not configured");
});
```

--------------------------------

### Optimizing HTTP Connection Pooling in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

Configures 'SocketsHttpHandlerOptions' for 'HttpClient' to optimize connection pooling by setting 'PooledConnectionLifetime', 'MaxConnectionsPerServer', 'KeepAlivePingTimeout', and 'KeepAlivePingDelay', improving network performance and resource utilization for the 'OpenRouterClient'.

```csharp
services.Configure<SocketsHttpHandlerOptions>(options =>
{
    options.PooledConnectionLifetime = TimeSpan.FromMinutes(2);
    options.MaxConnectionsPerServer = 20;
    options.KeepAlivePingTimeout = TimeSpan.FromSeconds(30);
    options.KeepAlivePingDelay = TimeSpan.FromSeconds(15);
});

services.AddHttpClient<IOpenRouterClient, OpenRouterClient>()
    .ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
    {
        PooledConnectionLifetime = TimeSpan.FromMinutes(2),
        MaxConnectionsPerServer = 20,
        EnableMultipleHttp2Connections = true
    });
```

--------------------------------

### Advanced Configuration Properties for ChatCompletionRequest (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Offers advanced settings for fine-tuning model behavior, such as `LogitBias` to influence token probabilities, `Logprobs` to return log probabilities, and `Stop` to define sequences that halt generation.

```C#
Dictionary<string, int>? LogitBias { get; set;}
bool? Logprobs { get; set;}
int? TopLogprobs { get; set;}
object? Stop { get; set;}
```

--------------------------------

### Validating OpenRouter Configuration Options in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

This code defines a custom validator for `OpenRouterOptions` using `IValidateOptions<T>` to ensure required configuration fields are present and valid. It checks for non-empty API Key and Base URL, and a positive Timeout, returning a `ValidateOptionsResult` indicating success or failure.

```C#
public class OpenRouterOptionsValidator : IValidateOptions<OpenRouterOptions>
{
    public ValidateOptionsResult Validate(string name, OpenRouterOptions options)
    {
        var failures = new List<string>();
        
        if (string.IsNullOrEmpty(options.ApiKey))
            failures.Add("API Key is required");
            
        if (string.IsNullOrEmpty(options.BaseUrl))
            failures.Add("Base URL is required");
            
        if (options.Timeout <= TimeSpan.Zero)
            failures.Add("Timeout must be positive");
            
        if (failures.Count > 0)
            return ValidateOptionsResult.Fail(failures);
            
        return ValidateOptionsResult.Success;
    }
}

services.AddSingleton<IValidateOptions<OpenRouterOptions>, OpenRouterOptionsValidator>();
```

--------------------------------

### Implementing Refreshable Bearer Token Provider (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/authentication.md

Provides a skeleton for a RefreshableBearerTokenProvider that implements IAuthenticationProvider. It includes logic to automatically refresh the token if it's nearing expiry, ensuring continuous and uninterrupted authentication without manual intervention.

```C#
public class RefreshableBearerTokenProvider : IAuthenticationProvider
{
    private string _currentToken;
    private DateTime _tokenExpiry;
    private readonly ITokenRefreshService _refreshService;

    public async Task<string> GetAuthorizationHeaderAsync(CancellationToken cancellationToken = default)
    {
        if (DateTime.UtcNow >= _tokenExpiry.AddMinutes(-5))
        {
            var newToken = await _refreshService.RefreshTokenAsync(cancellationToken);
            _currentToken = newToken.AccessToken;
            _tokenExpiry = newToken.ExpiresAt;
        }

        return $"Bearer {_currentToken}";
    }

    public void Dispose() { }
}
```

--------------------------------

### Constructing OpenRouterModerationException (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This C# constructor initializes an `OpenRouterModerationException` with a message and an optional request ID. This exception is thrown when content submitted to the API is rejected by moderation systems due to harmful content or policy violations, indicating a content-related issue.

```csharp
public OpenRouterModerationException(string message, string? requestId = null);
```

--------------------------------

### Catching Specific OpenRouter Exceptions (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This snippet demonstrates how to catch different types of OpenRouter exceptions individually. It allows for distinct error handling logic, such as implementing exponential backoff for rate limits, refreshing authentication for auth errors, or fixing request parameters for validation issues.

```csharp
try
{
    var response = await client.Chat.CreateAsync(request);
}
catch (OpenRouterRateLimitException rateLimitEx)
{
    // Implement exponential backoff
    await WaitAndRetry(rateLimitEx.RetryAfter);
}
catch (OpenRouterAuthenticationException authEx)
{
    // Refresh authentication
    await RefreshApiKey();
}
catch (OpenRouterValidationException validationEx)
{
    // Fix request parameters
    FixValidationErrors(validationEx.ValidationErrors);
}
```

--------------------------------

### Tracking OpenRouter Exception Metrics (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This static method demonstrates how to collect metrics for OpenRouter exceptions, categorizing them by type, error code, and status code. It increments a general counter for all exceptions and specifically records retry-after durations for rate limit exceptions, useful for monitoring and alerting.

```csharp
public static void TrackExceptionMetrics(OpenRouterException exception)
{
    var tags = new Dictionary<string, string>
    {
        ["exception_type"] = exception.GetType().Name,
        ["error_code"] = exception.ErrorCode ?? "unknown",
        ["status_code"] = exception.StatusCode?.ToString() ?? "unknown"
    };
    
    // Increment counter
    Metrics.Counter("openrouter_exceptions_total", tags).Increment();
    
    // Track rate limits specifically
    if (exception is OpenRouterRateLimitException rateLimitEx && rateLimitEx.RetryAfter.HasValue)
    {
        Metrics.Histogram("openrouter_rate_limit_retry_after_seconds", tags)
            .Record(rateLimitEx.RetryAfter.Value.TotalSeconds);
    }
}
```

--------------------------------

### Response Configuration Properties for ChatCompletionRequest (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Configures the format and streaming behavior of the chat completion response. `ResponseFormat` dictates the desired output format (e.g., JSON), and `Stream` determines if the response should be streamed incrementally.

```C#
ResponseFormat? ResponseFormat { get; set;}
bool? Stream { get; set;}
```

--------------------------------

### Defining Default Web Search Options in OpenRouter .NET

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

This C# class defines the default parameters for web search operations within the OpenRouter .NET library. It specifies settings such as `MaxResults`, `AllowedDomains`, `BlockedDomains`, `TimeRange`, `SafetyLevel`, and `IncludeCitations`, which govern the standard behavior of web searches when no custom options are provided.

```C#
public class DefaultWebSearchOptions
{
    public int MaxResults { get; set; } = 5;
    public string[] AllowedDomains { get; set; } = null; // All domains
    public string[] BlockedDomains { get; set; } = null; // No restrictions
    public TimeRange TimeRange { get; set; } = TimeRange.AnyTime;
    public SearchSafety SafetyLevel { get; set; } = SearchSafety.Moderate;
    public bool IncludeCitations { get; set; } = true;
}
```

--------------------------------

### Properties for Tool Model (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Defines the structure of a tool that can be integrated into chat completion, typically representing a function. `Type` specifies the tool's category (defaulting to 'function'), and `Function` holds the detailed definition of the callable function.

```C#
string Type { get; set; } = "function";
FunctionDefinition Function { get; set; } = new();
```

--------------------------------

### Connection Settings in OpenRouterOptions (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This C# code defines properties within the `OpenRouterOptions` class for configuring connection parameters. It includes `BaseUrl` for the API endpoint, `Timeout` for overall operation timeout, and `RequestTimeout` for individual request timeouts, all with default values.

```C#
string BaseUrl { get; set; } = "https://openrouter.ai/api/v1";
TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(30);
TimeSpan RequestTimeout { get; set; } = TimeSpan.FromSeconds(100);
```

--------------------------------

### Retry Configuration in OpenRouterOptions (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This C# code defines properties within the `OpenRouterOptions` class for configuring retry behavior. `EnableRetry` controls whether retries are active, `MaxRetryAttempts` sets the maximum number of retries, and `RetryDelay` specifies the delay between attempts, all with default values.

```C#
bool EnableRetry { get; set; } = true;
int MaxRetryAttempts { get; set; } = 3;
TimeSpan RetryDelay { get; set; } = TimeSpan.FromMilliseconds(1000);
```

--------------------------------

### Core Properties for MessageContent Model (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Defines the properties for multi-modal message content, allowing for different types of content like text, images, and documents. `Type` specifies the content type, while `Text`, `ImageUrl`, and `DocumentUrl` hold the respective content details.

```C#
string Type { get; set; } = string.Empty;
string? Text { get; set;}
ImageUrl? ImageUrl { get; set;}
DocumentUrl? DocumentUrl { get; set;}
```

--------------------------------

### Processing Streaming Chunks with Cancellation (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/streaming.md

This snippet illustrates the use of C# async enumerable patterns with `await foreach` for processing streaming responses. It integrates a `CancellationToken` to allow for graceful cancellation of the stream processing, calling a `ProcessChunk` method for each received chunk.

```csharp
await foreach (var chunk in response.WithCancellation(cancellationToken))
{
    // Process each chunk as it arrives
    ProcessChunk(chunk);
}
```

--------------------------------

### Configuring HTTP Headers in OpenRouter Client (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This snippet defines properties for configuring default HTTP headers, including `DefaultHeaders` for a dictionary of custom headers, `HttpReferer` for the HTTP Referer header, and `XTitle` for a custom `X-Title` header. These properties allow users to customize the outgoing HTTP requests made by the OpenRouter client.

```csharp
Dictionary<string, string> DefaultHeaders { get; set; } = new();
string? HttpReferer { get; set; }
string? XTitle { get; set; }
```

--------------------------------

### Defining WebSearchOptions Properties in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This snippet defines the properties of the `WebSearchOptions` class, which configures web search integration for the model. It includes options to enable or disable web search, set `MaxResults` for search queries, and specify `SearchDepth` (e.g., 'basic' or 'advanced') for the search intensity.

```csharp
bool? Enabled { get; set; }
int? MaxResults { get; set; }
string? SearchDepth { get; set; }
```

--------------------------------

### Structured Error Logging for OpenRouter in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/error-handling.md

This C# `OpenRouterErrorHandler` class provides a structured approach to logging `OpenRouter` API operation failures. It captures detailed information, including exception type, status codes, and rate limit specifics, to aid in diagnostics and monitoring.

```csharp
public class OpenRouterErrorHandler
{
    private readonly ILogger<OpenRouterErrorHandler> logger;

    public async Task<T> HandleRequest<T>(Func<Task<T>> request, string operationName)
    {
        try
        {
            logger.LogInformation("Starting {Operation}", operationName);
            var result = await request();
            logger.LogInformation("Completed {Operation} successfully", operationName);
            return result;
        }
        catch (OpenRouterException ex)
        {
            logger.LogError(ex, 
                "OpenRouter operation {Operation} failed with {ExceptionType}: {Message}",
                operationName, ex.GetType().Name, ex.Message);
            
            // Log additional context based on exception type
            switch (ex)
            {
                case OpenRouterApiException apiEx:
                    logger.LogError("API Error - Status: {StatusCode}, Code: {ErrorCode}",
                        apiEx.StatusCode, apiEx.ErrorCode);
                    break;
                case OpenRouterRateLimitException rateLimitEx:
                    logger.LogError("Rate Limited - Retry After: {RetryAfter}, Usage: {Usage}",
                        rateLimitEx.RetryAfter, rateLimitEx.CurrentUsage);
                    break;
            }
            
            throw;
        }
    }
}
```

--------------------------------

### Extracting Tokens from AuthResponse (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/oauth.md

This snippet shows how to extract access and refresh tokens, along with their expiration time, from the `AuthResponse` object received after a successful token exchange. It also includes a placeholder for securely storing these tokens.

```C#
var authResponse = await client.Auth.ExchangeTokenAsync(request);
var accessToken = authResponse.AccessToken;
var refreshToken = authResponse.RefreshToken;
var expiresIn = authResponse.ExpiresIn;

// Store tokens securely
await StoreTokensSecurely(accessToken, refreshToken, expiresIn);
```

--------------------------------

### Accessing OAuth Service Methods (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/oauth.md

This snippet demonstrates how to access the OAuth service methods from the OpenRouter client. It retrieves the `IAuthService` instance and then calls `GetAuthorizationUrlAsync` to obtain the authorization URL, requiring a redirect URI and desired scopes.

```C#
var authService = client.Auth;
var authUrl = await authService.GetAuthorizationUrlAsync(redirectUri, scopes);
```

--------------------------------

### Defining Search Result Integration Structures in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/web-search.md

These C# classes define the data structures for integrating and representing web search results within AI-generated responses. SearchEnhancedResponse encapsulates the main AI response along with an array of SearchResult objects, citations, and metadata. SearchResult details individual search findings, including title, URL, snippet, publication date, domain, relevance score, and keywords, facilitating structured consumption of search data.

```C#
public class SearchEnhancedResponse
{
    public string MainResponse { get; set; }
    public SearchResult[] Sources { get; set; }
    public Citation[] Citations { get; set; }
    public SearchMetadata Metadata { get; set; }
}

public class SearchResult
{
    public string Title { get; set; }
    public string Url { get; set; }
    public string Snippet { get; set; }
    public DateTime PublishedDate { get; set; }
    public string Domain { get; set; }
    public float RelevanceScore { get; set; }
    public string[] Keywords { get; set; }
}
```

--------------------------------

### Validating C# Tool Results Against Schema

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/tools-and-functions.md

This C# class provides functionality to validate tool results against predefined JSON schemas. It parses the result string into a `JsonDocument` and then validates it using a schema retrieved based on the tool name. It handles `JsonException` during parsing and requires a mechanism to retrieve `JsonSchema` objects.

```csharp
public class ToolResultValidator
{
    public bool ValidateResult(string toolName, string result)
    {
        try
        {
            var schema = GetResultSchema(toolName);
            var jsonDocument = JsonDocument.Parse(result);
            return ValidateAgainstSchema(jsonDocument, schema);
        }
        catch (JsonException)
        {
            return false;
        }
    }
    
    private JsonSchema GetResultSchema(string toolName)
    {
        // Return expected schema for tool results
        return toolSchemas[toolName];
    }
}
```

--------------------------------

### Configuring Operation-Specific Timeouts for OpenRouter Client in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/configuration.md

Defines a 'TimeoutConfiguration' class to specify distinct timeouts for different API operations (e.g., chat completion, streaming, model list, file uploads) and shows how 'ConfigurableOpenRouterClient' uses these timeouts with 'CancellationTokenSource' for fine-grained control over API call durations.

```csharp
public class TimeoutConfiguration
{
    public TimeSpan ChatCompletion { get; set; } = TimeSpan.FromMinutes(2);
    public TimeSpan StreamingChat { get; set; } = TimeSpan.FromMinutes(5);
    public TimeSpan ModelList { get; set; } = TimeSpan.FromSeconds(30);
    public TimeSpan FileUploads { get; set; } = TimeSpan.FromMinutes(10);
}

public class ConfigurableOpenRouterClient : IOpenRouterClient
{
    private readonly TimeoutConfiguration timeouts;
    
    public async Task<ChatCompletionResponse> GetChatCompletionAsync(
        ChatCompletionRequest request, 
        CancellationToken cancellationToken = default)
    {
        using var timeoutCts = new CancellationTokenSource(timeouts.ChatCompletion);
        using var combinedCts = CancellationTokenSource.CreateLinkedTokenSource(
            cancellationToken, timeoutCts.Token);
            
        return await base.GetChatCompletionAsync(request, combinedCts.Token);
    }
}
```

--------------------------------

### Defining ToolChoice Properties in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This snippet defines the properties of the `ToolChoice` class, which controls the model's behavior regarding tool usage. It specifies a `Type` to indicate the choice strategy (e.g., 'auto', 'none', 'function') and an optional `Function` object if a specific tool function is to be chosen.

```csharp
string Type { get; set; } = string.Empty;
ToolChoiceFunction? Function { get; set;}
```

--------------------------------

### IChatRequestBuilder Provider Routing Method in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/services.md

This snippet defines the method for configuring provider routing preferences within the `IChatRequestBuilder`. It allows for custom configuration of how the chat request is routed to different AI providers based on specified preferences.

```C#
IChatRequestBuilder WithProviderRouting(Action<ProviderPreferences> configure);
```

--------------------------------

### Core Properties for Message Model (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Defines the fundamental properties of a chat message, including its `Role` (e.g., system, user, assistant), `Content` (which can be text or multi-modal), and properties related to tool calls (`ToolCalls`, `ToolCallId`).

```C#
string Role { get; set; } = string.Empty;
object? Content { get; set;}
string? Name { get; set;}
ToolCall[]? ToolCalls { get; set;}
string? ToolCallId { get; set;}
```

--------------------------------

### Constructor for OpenRouterAuthorizationException in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

Defines the constructor for OpenRouterAuthorizationException, which is thrown when the authenticated user lacks necessary permissions for an operation, allowing instantiation with a message and optional requestId.

```C#
public OpenRouterAuthorizationException(string message, string? requestId = null);
```

--------------------------------

### Retrieving Specific Model Details by ID (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/models.md

This snippet demonstrates how to fetch detailed information for a specific model by its ID, such as 'anthropic/claude-3-haiku', using the `GetModelDetailsAsync` method. It utilizes the `ModelDetailsRequest` for targeted queries.

```csharp
var modelDetails = await client.Models.GetModelDetailsAsync("anthropic/claude-3-haiku");
```

--------------------------------

### Convenience Properties for Message Model (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Provides read-only boolean properties to easily identify the type of message based on its role (e.g., `IsSystemMessage`, `IsUserMessage`). `TextContent` offers a convenient way to access the message's text content if available.

```C#
bool IsSystemMessage { get;}
bool IsUserMessage { get;}
bool IsAssistantMessage { get;}
bool IsToolMessage { get;}
string? TextContent { get;}
```

--------------------------------

### Enabling Usage Accounting for OpenRouter Chat Requests in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/credits.md

This code shows how to enable detailed usage accounting for chat requests by calling WithUsageAccounting(true). After execution, it retrieves and displays the total tokens used and the estimated cost, allowing for precise tracking of resource consumption per request.

```C#
var response = await client.Chat.CreateRequest()
    .WithModel("anthropic/claude-3-haiku")
    .WithUserMessage("Hello, world!")
    .WithUsageAccounting(true)
    .ExecuteAsync();

Console.WriteLine($"Tokens used: {response.Usage.TotalTokens}");
Console.WriteLine($"Estimated cost: ${response.Usage.EstimatedCost}");
```

--------------------------------

### Logging OpenRouter Exceptions Comprehensively (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This static method provides a structured way to log OpenRouter exceptions with varying log levels based on the exception type. It ensures consistent and detailed logging of critical diagnostic information such as message, error code, status code, and request ID.

```csharp
public static void LogOpenRouterException(ILogger logger, OpenRouterException exception)
{
    var logLevel = exception switch
    {
        OpenRouterAuthenticationException => LogLevel.Warning,
        OpenRouterRateLimitException => LogLevel.Information,
        OpenRouterValidationException => LogLevel.Warning,
        OpenRouterConfigurationException => LogLevel.Error,
        _ => LogLevel.Error
    };
    
    logger.Log(logLevel, exception, 
        "OpenRouter operation failed: {Message} | ErrorCode: {ErrorCode} | StatusCode: {StatusCode} | RequestId: {RequestId}",
        exception.Message, 
        exception.ErrorCode, 
        exception.StatusCode, 
        exception.RequestId);
}
```

--------------------------------

### Disposal Method for OpenRouterClient (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This C# code defines the `Dispose()` method for the `OpenRouterClient` class, implementing the `IDisposable` pattern. It ensures proper release of underlying HTTP resources, logs the disposal completion if a logger is configured, and prevents multiple disposal calls for thread-safe resource management.

```C#
public void Dispose()
```

--------------------------------

### Using WithStructuredOutput for Basic Typed Responses in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/structured-outputs.md

This snippet demonstrates how to define C# classes (PersonInfo, Address) for structured output and use the WithStructuredOutput<T>() method to extract strongly-typed data from an AI model's response. It shows the process of sending a chat message, requesting a structured output of type PersonInfo, and then retrieving the parsed object.

```C#
public class PersonInfo
{
    public string Name { get; set; }
    public int Age { get; set; }
    public string Email { get; set; }
    public string[] Hobbies { get; set; }
    public Address Address { get; set; }
}

public class Address
{
    public string Street { get; set; }
    public string City { get; set; }
    public string State { get; set; }
    public string ZipCode { get; set; }
}

var response = await client.Chat
    .WithModel("gpt-4")
    .WithMessages("Extract person info from: John Smith, 30 years old, lives at 123 Main St, Boston MA 02101, enjoys hiking and reading, email: john@example.com")
    .WithStructuredOutput<PersonInfo>()
    .ExecuteAsync();

PersonInfo person = response.GetStructuredOutput<PersonInfo>();
```

--------------------------------

### Implementing Streaming Cancellation with CancellationToken (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/streaming.md

This snippet demonstrates how to use a `CancellationTokenSource` to implement timeout-based cancellation for streaming operations. It wraps the stream processing in a `try-catch` block to gracefully handle `OperationCanceledException` when the token is cancelled, such as after a timeout.

```csharp
using var cts = new CancellationTokenSource(TimeSpan.FromMinutes(5));

try
{
    await foreach (var chunk in response.WithCancellation(cts.Token))
    {
        ProcessChunk(chunk);
    }
}
catch (OperationCanceledException)
{
    Console.WriteLine("Streaming cancelled due to timeout");
}
```

--------------------------------

### Constructing OpenRouterNetworkException (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This C# constructor initializes an `OpenRouterNetworkException` with a message and an `innerException`. This exception is thrown when network-level issues, such as DNS resolution failures, connection timeouts, or SSL/TLS errors, prevent the API call from completing successfully.

```csharp
public OpenRouterNetworkException(string message, Exception innerException);
```

--------------------------------

### Properties for FunctionDefinition Model (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Defines the properties of a function that can be called by the model. `Name` is the function's identifier, `Description` explains its purpose, and `Parameters` specifies its expected arguments using a JSON Schema object.

```C#
string Name { get; set; } = string.Empty;
string Description { get; set; } = string.Empty;
object? Parameters { get; set; }  // JSON Schema object
```

--------------------------------

### Defining ToolCall Properties in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This snippet defines the properties of the `ToolCall` class, which represents a function call initiated by the assistant. It includes an `Id` for unique identification, a `Type` (defaulting to 'function'), and a `Function` object containing details of the specific function being called.

```csharp
string Id { get; set; } = string.Empty;
string Type { get; set; } = "function";
FunctionCall Function { get; set; } = new();
```

--------------------------------

### Inspecting OpenRouter Exception Properties (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This snippet demonstrates how to access and utilize properties available on OpenRouter exceptions for detailed logging and integration with monitoring services. It extracts key diagnostic information like message, error code, status code, and request ID.

```csharp
catch (OpenRouterException ex)
{
    var logContext = new
    {
        Message = ex.Message,
        ErrorCode = ex.ErrorCode,
        StatusCode = ex.StatusCode,
        RequestId = ex.RequestId,
        InnerException = ex.InnerException?.Message
    };
    
    Logger.LogError("OpenRouter exception: {@LogContext}", logContext);
    
    // Send to monitoring service
    if (ex.RequestId != null)
    {
        TelemetryClient.TrackException(ex, new Dictionary<string, string>
        {
            ["RequestId"] = ex.RequestId,
            ["ErrorCode"] = ex.ErrorCode ?? "unknown"
        });
    }
}
```

--------------------------------

### Constructing OpenRouterValidationException (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This C# constructor for `OpenRouterValidationException` allows initializing the exception with a custom error message, an optional dictionary of validation errors, and an optional request ID. It is used when a request fails due to invalid parameters or format errors, providing detailed context for debugging.

```csharp
public OpenRouterValidationException(string message, Dictionary<string, string[]>? validationErrors = null, string? requestId = null);
```

--------------------------------

### Constructing OpenRouterStreamingException (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

These C# constructors for `OpenRouterStreamingException` allow initializing the exception with a message, with an overload for an `innerException`. This exception is thrown when problems occur during streaming operations, such as stream interruptions, invalid streaming formats, or connection loss.

```csharp
public OpenRouterStreamingException(string message);
public OpenRouterStreamingException(string message, Exception innerException);
```

--------------------------------

### Handling Insufficient Credits Exception in OpenRouter C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/credits.md

This snippet illustrates a try-catch block for gracefully handling InsufficientCreditsException when making OpenRouter chat requests. It provides a pattern for responding to scenarios where an operation fails due to insufficient credits, allowing for custom recovery logic like initiating a top-up.

```C#
try
{
    var response = await client.Chat.CreateRequest()
        .WithModel("anthropic/claude-3-haiku")
        .WithUserMessage("Hello")
        .ExecuteAsync();
}
catch (InsufficientCreditsException ex)
{
    // Handle insufficient credits
    await HandleLowCredits();
}
```

--------------------------------

### Handling OpenRouterRateLimitException in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

Illustrates how to handle OpenRouterRateLimitException by checking the RetryAfter property. If a retry duration is provided, the code waits for that period before suggesting a retry of the original request.

```C#
try
{
    var response = await client.Chat.CreateAsync(request);
}
catch (OpenRouterRateLimitException ex)
{
    if (ex.RetryAfter.HasValue)
    {
        Console.WriteLine($"Rate limited. Retry after: {ex.RetryAfter.Value}");
        await Task.Delay(ex.RetryAfter.Value);
        // Retry the request
    }
}
```

--------------------------------

### Defining ConfigurationKey Property in OpenRouterConfigurationException (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This C# snippet defines the `ConfigurationKey` property within the `OpenRouterConfigurationException` class. This property stores the specific configuration key that caused the issue, aiding in debugging and identifying misconfigurations within the application.

```csharp
string? ConfigurationKey { get; }
```

--------------------------------

### Additional Properties of OpenRouterApiException in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

Introduces the ErrorDetails property specific to OpenRouterApiException, which provides detailed error information directly from the API response, supplementing the base exception properties.

```C#
object? ErrorDetails { get; }
```

--------------------------------

### Creating Complex Analytics JSON Schema in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/structured-outputs.md

This C# snippet provides a static method CreateAnalyticsSchema within a SchemaBuilder class to construct a more complex JSON schema. The schema defines nested objects for metrics, timeframes, and an array of insights, demonstrating advanced structuring with various data types, minimum/maximum values, date-time formats, and required properties for analytical data.

```C#
public class SchemaBuilder
{
    public static object CreateAnalyticsSchema()
    {
        return new
        {
            type = "object",
            properties = new
            {
                metrics = new
                {
                    type = "object",
                    properties = new
                    {
                        totalUsers = new { type = "integer", minimum = 0 },
                        activeUsers = new { type = "integer", minimum = 0 },
                        conversionRate = new { type = "number", minimum = 0, maximum = 1 },
                        revenue = new { type = "number", minimum = 0 }
                    },
                    required = new[] { "totalUsers", "activeUsers" }
                },
                timeframe = new
                {
                    type = "object",
                    properties = new
                    {
                        start = new { type = "string", format = "date-time" },
                        end = new { type = "string", format = "date-time" }
                    },
                    required = new[] { "start", "end" }
                },
                insights = new
                {
                    type = "array",
                    items = new
                    {
                        type = "object",
                        properties = new
                        {
                            category = new { type = "string" },
                            impact = new { type = "string", @enum = new[] { "high", "medium", "low" } },
                            description = new { type = "string" },
                            actionable = new { type = "boolean" }
                        },
                        required = new[] { "category", "impact", "description" }
                    },
                    maxItems = 5
                }
            },
            required = new[] { "metrics", "timeframe" }
        };
    }
}
```

--------------------------------

### Processing Documents for Structured Data Extraction in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/structured-outputs.md

This C# code demonstrates a 'DocumentProcessor' class that leverages an AI chat client to extract structured data from document text. It defines an 'ExtractedData' class with nested types (Metadata, Contacts, Financials, KeyPoints) to represent the desired output structure, enabling type-safe data extraction from unstructured input.

```csharp
public class DocumentProcessor
{
    public async Task<ExtractedData> ProcessDocument(string documentText)
    {
        return await client.Chat
            .WithModel("gpt-4")
            .WithMessages($"Extract structured data from: {documentText}")
            .WithStructuredOutput<ExtractedData>()
            .ExecuteAsync()
            .ContinueWith(response => response.Result.GetStructuredOutput<ExtractedData>());
    }
}

public class ExtractedData
{
    public DocumentMetadata Metadata { get; set; }
    public ContactInfo[] Contacts { get; set; }
    public FinancialInfo[] Financials { get; set; }
    public KeyPoint[] KeyPoints { get; set; }
}
```

--------------------------------

### Standardizing API Response Format in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/structured-outputs.md

This C# code defines a generic 'ApiResponseWrapper' class and an 'ErrorInfo' class to standardize the format of API responses. It ensures consistency across different API endpoints by providing common fields like success status, messages, data payload, error details, and a timestamp, making API consumption more predictable.

```csharp
public class ApiResponseWrapper<T>
{
    public bool Success { get; set; }
    public string Message { get; set; }
    public T Data { get; set; }
    public ErrorInfo[] Errors { get; set; }
    public DateTime Timestamp { get; set; }
}

public class ErrorInfo
{
    public string Code { get; set; }
    public string Message { get; set; }
    public string Field { get; set; }
}
```

--------------------------------

### Additional Properties of OpenRouterRateLimitException in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

Introduces the RetryAfter property specific to OpenRouterRateLimitException, indicating the recommended time to wait before retrying a request after exceeding API rate limits.

```C#
TimeSpan? RetryAfter { get; }
```

--------------------------------

### Using WithStructuredOutput<T>() for Type-Safe JSON Extraction in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/fluent-api.md

This snippet demonstrates how to use `WithStructuredOutput<T>()` to automatically extract structured data from a chat response into a C# object. It defines a `PersonInfo` class and shows how to execute a chat request to populate an instance of this class, leveraging generic constraints for type safety and automatic JSON schema serialization.

```C#
public class PersonInfo
{
    public string Name { get; set; }
    public int Age { get; set; }
    public string[] Hobbies { get; set; }
}

var response = await client.Chat
    .WithModel("gpt-4")
    .WithMessages("Extract person info from: John is 30 and likes hiking, reading.")
    .WithStructuredOutput<PersonInfo>()
    .ExecuteAsync();
```

--------------------------------

### Handling OpenRouterAuthenticationException in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

Demonstrates how to catch and handle OpenRouterAuthenticationException when an API request fails due to invalid, expired, or missing API keys. It logs the error message and request ID, suggesting re-authentication or configuration updates.

```C#
try
{
    var response = await client.Chat.CreateRequest()
        .WithModel("gpt-3.5-turbo")
        .WithUserMessage("Hello!")
        .ExecuteAsync();
}
catch (OpenRouterAuthenticationException ex)
{
    Console.WriteLine($"Authentication failed: {ex.Message}");
    Console.WriteLine($"Request ID: {ex.RequestId}");
    // Handle re-authentication or configuration update
}
```

--------------------------------

### Core Properties for ChatCompletionRequest (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

Defines the essential properties for a chat completion request, including the model identifier and an array of messages that form the conversation history. `Model` specifies the AI model to use, and `Messages` contains the sequence of `Message` objects.

```C#
string Model { get; set; } = string.Empty;
Message[] Messages { get; set; } = Array.Empty<Message>();
```

--------------------------------

### Constructing OpenRouterTimeoutException (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

These C# constructors for `OpenRouterTimeoutException` allow initializing the exception with a message and the `TimeSpan` that was exceeded. An overload also accepts an `innerException` for chaining. This exception is thrown when an API request exceeds its configured timeout duration.

```csharp
public OpenRouterTimeoutException(string message, TimeSpan timeout);
public OpenRouterTimeoutException(string message, TimeSpan timeout, Exception innerException);
```

--------------------------------

### Setting Streaming Optimizations in OpenRouter Client (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This snippet defines properties for controlling streaming behavior. `EnableStreamingOptimizations` enables or disables optimizations for streaming responses, defaulting to `true`. `StreamingBufferSize` sets the buffer size in bytes for streaming operations, defaulting to 8192 bytes, which can impact performance and memory usage during data transfer.

```csharp
bool EnableStreamingOptimizations { get; set; } = true;
int StreamingBufferSize { get; set; } = 8192;
```

--------------------------------

### Properties of OpenRouterException in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

Defines common properties available on the base OpenRouterException class, including ErrorCode for specific API or library errors, StatusCode for HTTP status, and RequestId for unique request identification, useful for debugging and support.

```C#
string? ErrorCode { get; }
int? StatusCode { get; }
string? RequestId { get; }
```

--------------------------------

### Validating JSON Schema Structure at Runtime in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/structured-outputs.md

This C# snippet presents a SchemaValidator class with a ValidateSchema method to perform basic runtime validation of a given JSON schema. It serializes the schema to JSON, parses it, and then checks for the presence of a "type" property and iterates through "properties" to validate each property definition, providing a mechanism to ensure schema integrity before use.

```C#
public class SchemaValidator
{
    public bool ValidateSchema(object schema)
    {
        try
        {
            var jsonSchema = JsonSerializer.Serialize(schema);
            var parsedSchema = JsonDocument.Parse(jsonSchema);
            
            return ValidateSchemaStructure(parsedSchema);
        }
        catch (Exception)
        {
            return false;
        }
    }
    
    private bool ValidateSchemaStructure(JsonDocument schema)
    {
        var root = schema.RootElement;
        
        // Validate required schema properties
        if (!root.TryGetProperty("type", out _))
            return false;
            
        if (root.TryGetProperty("properties", out var props))
        {
            // Validate each property definition
            foreach (var property in props.EnumerateObject())
            {
                if (!ValidatePropertyDefinition(property.Value))
                    return false;
            }
        }
        
        return true;
    }
}
```

--------------------------------

### Limiting Response Length with Max Tokens in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/chat-completions.md

This snippet shows how to use the WithMaxTokens() method to limit the maximum number of tokens (words or sub-words) in the model's response. This helps control the verbosity and cost of the generated output.

```C#
builder.WithMaxTokens(150);
```

--------------------------------

### Deserializing API Responses to Typed Objects in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/structured-outputs.md

This C# class provides a generic mechanism to deserialize `ChatCompletionResponse` content into a specified .NET type `T`. It configures `JsonSerializerOptions` for camel case property naming, case-insensitive matching, and enum string conversion, handling `JsonException` during deserialization.

```C#
public class StructuredResponseProcessor<T>
{
    public T ProcessResponse(ChatCompletionResponse response)
    {
        var content = response.Choices[0].Message.Content;
        
        try
        {
            var options = new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                PropertyNameCaseInsensitive = true,
                Converters = { new JsonStringEnumConverter() }
            };
            
            return JsonSerializer.Deserialize<T>(content, options);
        }
        catch (JsonException ex)
        {
            throw new StructuredOutputException(
                $"Failed to deserialize response to {typeof(T).Name}", ex);
        }
    }
}
```

--------------------------------

### Generating JSON Schema from .NET Types in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/structured-outputs.md

This C# class provides static methods to automatically generate a JSON schema object from a given .NET type using reflection. It handles primitive types, enums, collection types, and complex object types, extracting properties, their types, and identifying required fields based on conventions or attributes.

```C#
public class JsonSchemaGenerator
{
    public static object Generate<T>()
    {
        return Generate(typeof(T));
    }
    
    public static object Generate(Type type)
    {
        if (type.IsPrimitive || type == typeof(string))
            return GeneratePrimitiveSchema(type);
            
        if (type.IsEnum)
            return GenerateEnumSchema(type);
            
        if (IsCollectionType(type))
            return GenerateArraySchema(type);
            
        return GenerateObjectSchema(type);
    }
    
    private static object GenerateObjectSchema(Type type)
    {
        var properties = new Dictionary<string, object>();
        var required = new List<string>();
        
        foreach (var prop in type.GetProperties())
        {
            var jsonName = GetJsonPropertyName(prop);
            properties[jsonName] = Generate(prop.PropertyType);
            
            if (IsRequired(prop))
                required.Add(jsonName);
        }
        
        return new
        {
            type = "object",
            properties = properties,
            required = required.ToArray()
        };
    }
}
```

--------------------------------

### Defining ResponseFormat Properties in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/models.md

This snippet defines the properties of the `ResponseFormat` class, which controls the desired format of the model's response. It includes a `Type` property (defaulting to 'text') and an optional `Schema` property for specifying a JSON schema when a structured JSON response is required.

```csharp
string Type { get; set; } = "text";
object? Schema { get; set;}
```

--------------------------------

### Revoking and Deleting an API Key (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/features/api-keys.md

This C# method demonstrates how to securely revoke and delete an API key by its ID using the DeleteKeyAsync method of the OpenRouter client's Keys service. It provides a confirmation message upon successful deletion.

```csharp
public async Task RevokeKey(string keyId)
{
    await client.Keys.DeleteKeyAsync(keyId);
    Console.WriteLine($"Key {keyId} successfully revoked");
}
```

--------------------------------

### Configuring API Error Handling in OpenRouter Client (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/client.md

This snippet defines a boolean property `ThrowOnApiErrors` that controls whether the OpenRouter client should throw exceptions when API errors occur. When set to `true` (default), the client will throw an exception upon receiving an API error, allowing for immediate error handling. If set to `false`, errors might be returned as part of the response object instead.

```csharp
bool ThrowOnApiErrors { get; set; } = true;
```

--------------------------------

### Defining Custom JSON Schema for OpenRouter Chat API in C#

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/advanced/structured-outputs.md

This snippet demonstrates how to manually define a JSON schema in C# using an anonymous object for structured output. It shows how to specify data types, enums, ranges, array items, and required fields for sentiment analysis and summary generation. The schema is then used with the WithStructuredOutput method of the OpenRouter chat client to enforce the output format from a model like "claude-3-sonnet".

```C#
var customSchema = new
{
    type = "object",
    properties = new
    {
        analysis = new
        {
            type = "object",
            properties = new
            {
                sentiment = new
                {
                    type = "string",
                    @enum = new[] { "positive", "negative", "neutral" }
                },
                confidence = new
                {
                    type = "number",
                    minimum = 0.0,
                    maximum = 1.0
                },
                keywords = new
                {
                    type = "array",
                    items = new { type = "string" },
                    maxItems = 10
                }
            },
            required = new[] { "sentiment", "confidence" }
        },
        summary = new
        {
            type = "string",
            maxLength = 500
        }
    },
    required = new[] { "analysis" }
};

var response = await client.Chat
    .WithModel("claude-3-sonnet")
    .WithMessages("Analyze the sentiment: 'I love this product! It works perfectly.'")
    .WithStructuredOutput(customSchema)
    .ExecuteAsync();
```

--------------------------------

### Defining ProviderName Property in OpenRouterProviderException (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This C# snippet defines the `ProviderName` property within the `OpenRouterProviderException` class. This property stores the name of the upstream provider that caused the issue, helping to identify the source of errors like API unavailability or rate limits from a specific provider.

```csharp
string? ProviderName { get; }
```

--------------------------------

### Defining ValidationErrors Property in OpenRouterValidationException (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This C# snippet defines the `ValidationErrors` property within the `OpenRouterValidationException` class. This property is a dictionary that holds detailed validation error information, where keys represent field names and values are arrays of error messages for those fields. It is used to provide specific feedback when request validation fails.

```csharp
Dictionary<string, string[]>? ValidationErrors { get; }
```

--------------------------------

### Defining Timeout Property in OpenRouterTimeoutException (C#)

Source: https://github.com/xyoz-dev/openrouter/blob/master/docs/api-reference/exceptions.md

This C# snippet defines the `Timeout` property within the `OpenRouterTimeoutException` class. This property stores the `TimeSpan` value representing the duration after which the request timed out. It helps in understanding the specific timeout period that was exceeded.

```csharp
TimeSpan Timeout { get; }
```

=== COMPLETE CONTENT === This response contains all available snippets from this library. No additional content exists. Do not make further requests.